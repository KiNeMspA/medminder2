// Project: medminder2
// File: lib/common/constants/app_strings.dart
// lib/core/app_strings.dart
import '../medication_matrix.dart';

class Units {
  static const List<String> forms = [
    'Tablet',
    'Capsule',
    'Injection',
    'Drops',
    'Inhaler',
    'Ointment/Cream',
    'Patch',
    'Nasal Spray',
    'Suppository',
  ];
}

// --- FILE BREAK ---

// File: lib/common/mixins/controller_mixin.dart
// lib/core/controller_mixin.dart
import 'package:flutter/material.dart';

mixin ControllerMixin<T extends StatefulWidget> on State<T> {
  void setupListeners(List<TextEditingController> controllers, VoidCallback listener) {
    for (var controller in controllers) {
      controller.addListener(listener);
    }
  }

  void disposeControllers(List<TextEditingController> controllers) {
    for (var controller in controllers) {
      controller
        ..removeListener(() {})
        ..dispose();
    }
  }
}

// --- FILE BREAK ---

// File: lib/common/theme/app_theme.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

final appTheme = ThemeData(
  primaryColor: const Color(0xFF6200EE),
  colorScheme: ColorScheme.fromSeed(
    seedColor: const Color(0xFF6200EE),
    primary: const Color(0xFF6200EE),
    secondary: const Color(0xFF03DAC6),
    surface: Colors.white,
    background: const Color(0xFFF5F5F5),
    error: const Color(0xFFB00020),
    onPrimary: Colors.white,
    onSecondary: Colors.black,
    onSurface: Colors.black87,
    onBackground: Colors.black87,
    onError: Colors.white,
    brightness: Brightness.light,
  ),
  scaffoldBackgroundColor: const Color(0xFFF5F5F5),
  cardTheme: CardThemeData(
    elevation: 8,
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
    color: Colors.white.withOpacity(0.9),
    shadowColor: Colors.black26,
    margin: EdgeInsets.zero,
  ),
  textTheme: TextTheme(
    displayLarge: GoogleFonts.poppins(fontSize: 32, fontWeight: FontWeight.bold, color: Colors.black87),
    titleLarge: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.w600, color: const Color(0xFF6200EE)),
    bodyLarge: GoogleFonts.poppins(fontSize: 16, color: Colors.black87),
    bodyMedium: GoogleFonts.poppins(fontSize: 14, color: Colors.black54),
  ),
  inputDecorationTheme: InputDecorationTheme(
    filled: true,
    fillColor: Colors.white.withOpacity(0.7),
    border: OutlineInputBorder(
      borderRadius: BorderRadius.circular(12),
      borderSide: BorderSide.none,
    ),
    focusedBorder: OutlineInputBorder(
      borderRadius: BorderRadius.circular(12),
      borderSide: const BorderSide(color: Color(0xFF6200EE), width: 2),
    ),
    labelStyle: GoogleFonts.poppins(color: Colors.black54),
    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
  ),

  bottomNavigationBarTheme: const BottomNavigationBarThemeData(
    backgroundColor: Colors.white,
    selectedItemColor: Colors.blue,
    unselectedItemColor: const Color(0xFFBABABA), // Explicit dark gray
    selectedLabelStyle: TextStyle(fontWeight: FontWeight.bold),
    unselectedLabelStyle: TextStyle(fontWeight: FontWeight.normal),
    type: BottomNavigationBarType.fixed, // Ensure consistent rendering
  ),

  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: const Color(0xFF6200EE),
      foregroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
      elevation: 4,
      textStyle: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w600),
    ),
  ),
  iconTheme: const IconThemeData(color: Color(0xFF6200EE)),
  pageTransitionsTheme: const PageTransitionsTheme(
    builders: {
      TargetPlatform.android: ZoomPageTransitionsBuilder(),
      TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
    },
  ),
);

// --- FILE BREAK ---

// File: lib/common/utils/calculations.dart
// lib/core/calculations.dart
import '../medication_matrix.dart';

class MedCalculations {
  static double convertUnit(double value, String fromUnit, String toUnit, {double? dropSizeML}) {
    return MedicationMatrix.convertUnit(value, fromUnit, toUnit, dropSizeML: dropSizeML);
  }

  static double dosePerKg(double weightKg, double doseMgPerKg, String unit) {
    if (!MedicationMatrix.getAdministrationUnits(MedicationType.tablet).contains(unit)) {
      throw Exception('Invalid dose unit: $unit');
    }
    double dose = weightKg * doseMgPerKg;
    return convertUnit(dose, 'mg', unit);
  }

  static double reconstitute(double powderMg, double solventMl, double desiredMgPerMl) {
    return powderMg / desiredMgPerMl;
  }

  static String formatNumber(double value) {
    return value.toStringAsFixed(4).replaceAll(RegExp(r'0+$'), '').replaceAll(RegExp(r'\.$'), '');
  }
}

// --- FILE BREAK ---

// File: lib/common/utils/formatters.dart
import 'package:flutter/services.dart';

class DecimalTextInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
      TextEditingValue oldValue, TextEditingValue newValue) {
    final regEx = RegExp(r'^\d*\.?\d{0,2}$');
    return regEx.hasMatch(newValue.text) ? newValue : oldValue;
  }
}

class Utils {
  static String removeTrailingZeros(double value) {
    return value.toStringAsFixed(value.truncateToDouble() == value ? 0 : 2);
  }
}

// --- FILE BREAK ---

// File: lib/common/form_styles.dart
// lib/common/form_styles.dart
import 'package:flutter/material.dart';

class FormStyles {
  static const double fullWidthField = double.infinity;
  static const double integerFieldWidthPercent = 0.6;
  static const EdgeInsets buttonPadding = EdgeInsets.symmetric(horizontal: 4.0);
}

// --- FILE BREAK ---

// File: lib/common/medication_matrix.dart
import 'package:flutter/material.dart';
import 'constants/app_strings.dart';

/// Enum defining supported medication types.
enum MedicationType {
  tablet,
  capsule,
  injection,
  drops,
  inhaler,
  ointmentCream,
  patch,
  nasalSpray,
  suppository,
}

/// Enum defining quantity types for medications.
enum MedicationQuantityType {
  tablet,
  capsule,
  vial,
  ampule,
  bottle,
  inhaler,
  tube,
  jar,
  box,
  puff,
  dose,
  spray,
  suppository,
}

/// Enum defining administration methods for medications.
enum MedicationAdministrationType {
  none,
  syringe,
  dropper,
  inhaler,
  applicator,
  finger,
  patch,
  pump,
  suppository,
}

/// Core class for managing medication configurations, unit conversions, and dose calculations.
class MedicationMatrix {
  /// Matrix mapping each MedicationType to its configuration.
  static const Map<MedicationType, Map<String, dynamic>> matrix = {
    MedicationType.tablet: {
      'concentrationUnits': ['mg', 'mcg'],
      'concentrationRange': [0.01, 999.0],
      'quantityType': [MedicationQuantityType.tablet],
      'quantityUnits': ['Tablet'],
      'quantityRange': [0.25, 100.0], // Tighter range for tablets
      'administrationType': MedicationAdministrationType.none,
      'administrationSizes': [],
      'calculationRequired': false,
      'administrationUnits': ['mg', 'mcg'],
      'administrationRange': [0.01, 999.0],
    },
    MedicationType.capsule: {
      'concentrationUnits': ['mg', 'mcg'],
      'concentrationRange': [0.01, 999.0],
      'quantityType': [MedicationQuantityType.capsule],
      'quantityUnits': ['Capsule'],
      'quantityRange': [0.25, 100.0],
      'administrationType': MedicationAdministrationType.none,
      'administrationSizes': [],
      'calculationRequired': false,
      'administrationUnits': ['mg', 'mcg'],
      'administrationRange': [0.01, 999.0],
    },
    MedicationType.drops: {
      'concentrationUnits': ['mg/mL', 'mcg/mL'],
      'concentrationRange': [0.01, 999.0],
      'quantityType': [MedicationQuantityType.vial, MedicationQuantityType.bottle],
      'quantityUnits': ['mL'],
      'quantityRange': [0.01, 100.0],
      'administrationType': MedicationAdministrationType.dropper,
      'administrationSizes': [0.025, 0.05, 0.1], // Common dropper sizes
      'calculationRequired': true,
      'administrationUnits': ['mL', 'drop'],
      'administrationRange': [0.01, 10.0], // Smaller range for drops
    },
    MedicationType.injection: {
      'concentrationUnits': ['mg/mL', 'mcg/mL'],
      'concentrationRange': [0.0001, 999.0],
      'quantityType': [MedicationQuantityType.vial, MedicationQuantityType.ampule],
      'quantityUnits': ['mL'],
      'quantityRange': [0.01, 50.0], // Tighter range for injections
      'administrationType': MedicationAdministrationType.syringe,
      'administrationSizes': [0.3, 0.5, 1.0, 3.0, 5.0],
      'calculationRequired': true,
      'administrationUnits': ['mL'],
      'administrationRange': [0.01, 10.0],
    },
    MedicationType.inhaler: {
      'concentrationUnits': ['mcg/puff', 'mg/puff'],
      'concentrationRange': [0.01, 999.0],
      'quantityType': [MedicationQuantityType.inhaler],
      'quantityUnits': ['Puff', 'Dose'],
      'quantityRange': [1.0, 200.0], // Puffs per canister
      'administrationType': MedicationAdministrationType.inhaler,
      'administrationSizes': [], // Inhalers typically have fixed puff sizes
      'calculationRequired': true, // For puff-based dosing
      'administrationUnits': ['puff'],
      'administrationRange': [1.0, 10.0], // Max puffs per dose
    },
    MedicationType.ointmentCream: {
      'concentrationUnits': ['% (w/w)', 'mg/g', 'mcg/g'],
      'concentrationRange': [0.01, 100.0], // % up to 100
      'quantityType': [MedicationQuantityType.tube, MedicationQuantityType.jar],
      'quantityUnits': ['g', 'mL'],
      'quantityRange': [1.0, 500.0], // Common tube/jar sizes
      'administrationType': MedicationAdministrationType.applicator,
      'administrationSizes': [0.5, 1.0, 2.0], // Fingertip units
      'calculationRequired': true,
      'administrationUnits': ['g', 'cm'],
      'administrationRange': [0.1, 50.0],
    },
    MedicationType.patch: {
      'concentrationUnits': ['mg/day', 'mcg/hr'],
      'concentrationRange': [0.01, 999.0],
      'quantityType': [MedicationQuantityType.box],
      'quantityUnits': ['Patch'],
      'quantityRange': [1.0, 30.0], // Patches per box
      'administrationType': MedicationAdministrationType.patch,
      'administrationSizes': [],
      'calculationRequired': false,
      'administrationUnits': ['patch'],
      'administrationRange': [1.0, 2.0], // Typically 1 patch
    },
    MedicationType.nasalSpray: {
      'concentrationUnits': ['mg/mL', 'mcg/spray'],
      'concentrationRange': [0.01, 999.0],
      'quantityType': [MedicationQuantityType.bottle],
      'quantityUnits': ['Spray', 'mL'],
      'quantityRange': [1.0, 100.0],
      'administrationType': MedicationAdministrationType.pump,
      'administrationSizes': [0.05, 0.1], // Spray volumes
      'calculationRequired': true,
      'administrationUnits': ['spray'],
      'administrationRange': [1.0, 10.0], // Sprays per dose
    },
    MedicationType.suppository: {
      'concentrationUnits': ['mg', 'mcg'],
      'concentrationRange': [0.01, 999.0],
      'quantityType': [MedicationQuantityType.box],
      'quantityUnits': ['Suppository'],
      'quantityRange': [1.0, 30.0],
      'administrationType': MedicationAdministrationType.suppository,
      'administrationSizes': [],
      'calculationRequired': false,
      'administrationUnits': ['suppository'],
      'administrationRange': [1.0, 2.0],
    },
  };

  /// Conversion factors for units (in mg or mL where applicable).
  static const Map<String, double> unitConversions = {
    'mg': 1.0,
    'mcg': 0.001,
    'mL': 1.0,
    'g': 1000.0, // 1000 mg per g
    'cm': 0.5, // Approx 0.5g per cm for ointment (fingertip unit)
    'spray': 0.1, // Default for nasal spray
    'puff': 1.0, // Inhaler-specific
    'drop': 0.05, // Default drop size; override with dropSizeML
    'patch': 1.0, // Single patch
    'suppository': 1.0, // Single suppository
  };

  /// Returns valid concentration units for a medication type.
  static List<String> getConcentrationUnits(MedicationType type) {
    return List<String>.from(matrix[type]!['concentrationUnits']);
  }

  /// Returns valid quantity units for a medication type.
  static List<String> getQuantityUnits(MedicationType type) {
    return List<String>.from(matrix[type]!['quantityUnits']);
  }

  /// Returns valid administration units for a medication type.
  static List<String> getAdministrationUnits(MedicationType type) {
    return List<String>.from(matrix[type]!['administrationUnits']);
  }

  /// Checks if dose calculation is required for a medication type.
  static bool isCalculationRequired(MedicationType type) {
    return matrix[type]!['calculationRequired'] as bool;
  }

  /// Returns available administration sizes (e.g., syringe sizes) for a medication type.
  static List<double> getAdministrationSizes(MedicationType type) {
    return List<double>.from(matrix[type]!['administrationSizes']);
  }

  /// Converts a value between units, with optional drop size override.
  static double convertUnit(double value, String fromUnit, String toUnit, {double? dropSizeML}) {
    if (fromUnit == toUnit) return value;
    final effectiveFrom = fromUnit == 'drop' && dropSizeML != null ? dropSizeML : unitConversions[fromUnit] ?? 1.0;
    final effectiveTo = toUnit == 'drop' && dropSizeML != null ? dropSizeML : unitConversions[toUnit] ?? 1.0;
    if (effectiveFrom == 0 || effectiveTo == 0) {
      throw Exception('Invalid unit: $fromUnit or $toUnit');
    }
    return value * effectiveFrom / effectiveTo;
  }

  /// Calculates the administration dose (e.g., mL for injections, puffs for inhalers).
  static double calculateAdministrationDose({
    required MedicationType type,
    required double concentrationValue,
    required String concentrationUnit,
    required double desiredDose,
    required String doseUnit,
    double? dropSizeML,
  }) {
    if (!isCalculationRequired(type)) return desiredDose;

    // Convert desired dose to concentration unit
    final doseInConcentrationUnit = convertUnit(desiredDose, doseUnit, concentrationUnit, dropSizeML: dropSizeML);

    // Calculate volume or quantity
    switch (type) {
      case MedicationType.injection:
      case MedicationType.drops:
        if (concentrationUnit.contains('/mL')) {
          return doseInConcentrationUnit / concentrationValue; // e.g., 0.25 mg / 2 mg/mL = 0.125 mL
        }
        break;
      case MedicationType.inhaler:
        if (concentrationUnit.contains('/puff')) {
          return doseInConcentrationUnit / concentrationValue; // e.g., 100 mcg / 50 mcg/puff = 2 puffs
        }
        break;
      case MedicationType.ointmentCream:
        if (concentrationUnit.contains('/g') || concentrationUnit == '% (w/w)') {
          return doseInConcentrationUnit / (concentrationUnit == '% (w/w)' ? concentrationValue * 10 : concentrationValue); // % to mg/g
        }
        break;
      case MedicationType.nasalSpray:
        if (concentrationUnit.contains('/spray')) {
          return doseInConcentrationUnit / concentrationValue; // e.g., 100 mcg / 50 mcg/spray = 2 sprays
        }
        break;
      default:
        break;
    }
    throw Exception('Unsupported calculation for $type with $concentrationUnit');
  }

  /// Validates a value against the allowed range for a given type and field.
  static bool isValidValue(MedicationType type, double value, String field) {
    if (value <= 0) return false;
    final range = matrix[type]![
    field == 'concentration' ? 'concentrationRange' : field == 'quantity' ? 'quantityRange' : 'administrationRange'] as List<double>;
    return value >= range[0] && value <= range[1];
  }

  /// Maps a database Medication.form string to a MedicationType.
  static MedicationType formToType(String form) {
    final normalizedForm = form.toLowerCase().replaceAll('/', '').replaceAll(' ', '');
    return MedicationType.values.firstWhere(
          (type) => type.toString().split('.').last == normalizedForm,
      orElse: () => MedicationType.tablet,
    );
  }
}

// --- FILE BREAK ---

// File: lib/data/database.dart
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:logging/logging.dart';
part 'database.g.dart';

class StringListConverter extends TypeConverter<List<String>, String> {
  const StringListConverter();
  @override
  List<String> fromSql(String fromDb) => fromDb.split(',').where((e) => e.isNotEmpty).toList();
  @override
  String toSql(List<String> value) => value.join(',');
}

class Medications extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().unique()();
  RealColumn get concentration => real()();
  TextColumn get concentrationUnit => text()();
  RealColumn get stockQuantity => real()();
  TextColumn get form => text()();
}

class Doses extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get medicationId => integer().references(Medications, #id)();
  TextColumn get medicationName => text()();
  RealColumn get amount => real()();
  TextColumn get unit => text()();
  DateTimeColumn get time => dateTime()();
  BoolColumn get taken => boolean().withDefault(const Constant(false))();
  RealColumn get weight => real().withDefault(const Constant(0.0))();
  TextColumn get name => text().nullable()();
}

class Schedules extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get medicationId => integer().references(Medications, #id)();
  TextColumn get medicationName => text()();
  IntColumn get doseId => integer().nullable().references(Doses, #id)();
  TextColumn get frequency => text()();
  TextColumn get days => text().map(const StringListConverter())();
  DateTimeColumn get time => dateTime()();
  TextColumn get name => text().withDefault(const Constant(''))();
  BoolColumn get notificationsEnabled => boolean().withDefault(const Constant(true))();
  TextColumn get notificationId => text().nullable()();
}

class DoseHistory extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get doseId => integer().references(Doses, #id)();
  DateTimeColumn get takenAt => dateTime()();
}

@DriftDatabase(tables: [Medications, Doses, Schedules, DoseHistory])
class AppDatabase extends _$AppDatabase {
  final Logger _logger = Logger('AppDatabase');

  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 9;

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onUpgrade: (Migrator m, int from, int to) async {
      _logger.info('Upgrading database from schema version $from to $to');
      if (from < 9) {
        await m.addColumn(doses, doses.medicationName);
        await m.addColumn(doses, doses.time);
        await m.addColumn(doses, doses.taken);
        await m.addColumn(schedules, schedules.medicationId);
        await m.addColumn(schedules, schedules.medicationName);
        await m.addColumn(schedules, schedules.notificationsEnabled);
        _logger.info('Added new columns for Doses and Schedules');
      }
      if (from <= 7) {
        await m.addColumn(schedules, schedules.notificationId);
        _logger.info('Added notificationId column to Schedules table');
      }
      if (from <= 6) {
        await m.deleteTable('ScheduleDoses');
        _logger.info('Ensured ScheduleDoses table is dropped');
      }
      if (from <= 5) {
        await m.deleteTable('ScheduleDoses');
        await m.addColumn(schedules, schedules.name);
        await m.alterTable(TableMigration(schedules));
        _logger.info('Dropped ScheduleDoses table, added name to Schedules, made doseId nullable');
      }
      if (from <= 4) {
        await m.createTable(schedules);
        _logger.info('Created Schedules table');
      }
      if (from <= 3) {
        await m.createTable(doseHistory);
        _logger.info('Created DoseHistory table');
      }
      if (from <= 2) {
        await m.createIndex(Index('medications', 'UNIQUE(name)'));
        _logger.info('Added unique constraint to Medications name');
      }
      if (from <= 1) {
        await m.addColumn(doses, doses.name);
        _logger.info('Added name column to Doses table');
      }
    },
  );

  Future<void> addMedication(MedicationsCompanion med) async {
    _logger.info('Adding medication: $med');
    await into(medications).insert(med);
  }

  Future<void> updateMedication(MedicationsCompanion med) async {
    _logger.info('Updating medication: $med');
    await (update(medications)..where((m) => m.id.equals(med.id.value))).write(med);
  }

  Future<Medication?> getMedicationById(int id) async {
    return await (select(medications)..where((m) => m.id.equals(id))).getSingleOrNull();
  }

  Future<void> updateMedicationStock(int id, double newQuantity) async {
    _logger.info('Updating medication stock: id=$id, newQuantity=$newQuantity');
    await (update(medications)..where((m) => m.id.equals(id))).write(
      MedicationsCompanion(stockQuantity: Value(newQuantity)),
    );
  }

  Future<List<Medication>> getMedications() => select(medications).get();

  Future<void> deleteMedication(int id) async {
    final doseIds = await (select(doses)..where((d) => d.medicationId.equals(id)))
        .map((d) => d.id)
        .get();
    await (delete(schedules)..where((s) => s.doseId.isIn(doseIds) | s.doseId.isNull())).go();
    await (delete(doses)..where((d) => d.medicationId.equals(id))).go();
    await (delete(medications)..where((m) => m.id.equals(id))).go();
    await _logDatabase();
  }

  Future<int> addDose(DosesCompanion dose) async {
    _logger.info('Adding dose: $dose');
    final doseId = await into(doses).insert(dose);
    await _logDatabase();
    return doseId;
  }

  Future<List<DoseHistoryData>> getDoseHistory(int doseId) async {
    return (select(doseHistory)..where((tbl) => tbl.doseId.equals(doseId))).get();
  }

  Future<void> updateDose(int id, DosesCompanion dose) async {
    _logger.info('Updating dose: id=$id, $dose');
    await (update(doses)..where((t) => t.id.equals(id))).write(dose);
    await _logDatabase();
  }

  Future<void> markDoseTaken(int id) async {
    _logger.info('Marking dose as taken: id=$id');
    await (update(doses)..where((t) => t.id.equals(id))).write(
      DosesCompanion(taken: const Value(true)),
    );
    await addDoseHistory(DoseHistoryCompanion(
      doseId: Value(id),
      takenAt: Value(DateTime.now()),
    ));
  }

  Future<void> skipDose(int id) async {
    _logger.info('Skipping dose: id=$id');
    await (delete(doses)..where((t) => t.id.equals(id))).go();
  }

  Future<Dose?> getDoseById(int id) async {
    return await (select(doses)..where((d) => d.id.equals(id))).getSingleOrNull();
  }

  Future<List<Dose>> getDoses(int medicationId) async {
    final doseList = await (select(doses)..where((d) => d.medicationId.equals(medicationId))).get();
    _logger.info('Doses fetched for medicationId=$medicationId: $doseList');
    return doseList;
  }

  Future<List<Dose>> getAllDoses() async {
    final doseList = await select(doses).get();
    _logger.info('All doses fetched: $doseList');
    return doseList;
  }

  Future<void> deleteDose(int id) async {
    await (update(schedules)..where((s) => s.doseId.equals(id))).write(SchedulesCompanion(doseId: Value(null)));
    await (delete(doseHistory)..where((h) => h.doseId.equals(id))).go();
    await (delete(doses)..where((d) => d.id.equals(id))).go();
    await _logDatabase();
  }

  Future<int> addSchedule(SchedulesCompanion schedule) async {
    _logger.info('Adding schedule: $schedule');
    final scheduleId = await into(schedules).insert(schedule);
    await _logDatabase();
    return scheduleId;
  }

  Future<void> updateSchedule(int id, SchedulesCompanion schedule) async {
    _logger.info('Updating schedule: id=$id, $schedule');
    await (update(schedules)..where((s) => s.id.equals(id))).write(schedule);
    await _logDatabase();
  }

  Future<Schedule?> getScheduleById(int id) async {
    return await (select(schedules)..where((s) => s.id.equals(id))).getSingleOrNull();
  }

  Future<List<Schedule>> getSchedules(int medicationId) async {
    final scheduleList = await (select(schedules)..where((s) => s.medicationId.equals(medicationId))).get();
    _logger.info('Schedules fetched for medicationId=$medicationId: $scheduleList');
    return scheduleList;
  }

  Future<List<Schedule>> getAllSchedules() async {
    final scheduleList = await select(schedules).get();
    _logger.info('All schedules fetched: $scheduleList');
    return scheduleList;
  }

  Future<void> deleteSchedule(int id) async {
    _logger.info('Deleting schedule: id=$id');
    await (delete(schedules)..where((s) => s.id.equals(id))).go();
    await _logDatabase();
  }

  Future<void> addDoseHistory(DoseHistoryCompanion history) async {
    _logger.info('Adding dose history: $history');
    await into(doseHistory).insert(history);
    await _logDatabase();
  }

  Future<void> copyDatabaseToPublicDirectory() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final dbFile = File(p.join(dbFolder.path, 'medminder.sqlite'));
    final publicDir = Directory('/sdcard/Download');
    final publicFile = File(p.join(publicDir.path, 'medminder.sqlite'));

    if (await dbFile.exists()) {
      try {
        await publicFile.parent.create(recursive: true);
        await dbFile.copy(publicFile.path);
        _logger.info('Database copied to: ${publicFile.path}');
      } catch (e) {
        _logger.severe('Failed to copy database: $e');
      }
    } else {
      _logger.severe('Database file does not exist at: ${dbFile.path}');
    }
  }

  Future<void> _logDatabase() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'medminder.sqlite'));
    if (await file.exists()) {
      _logger.info('Database file exists at: ${file.path}');
      final stats = await file.stat();
      _logger.info('Database file size: ${stats.size} bytes, modified: ${stats.modified}');
    } else {
      _logger.severe('Database file does not exist at: ${file.path}');
    }
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'medminder.sqlite'));
    final logger = Logger('AppDatabase');
    logger.info('Opening database at: ${file.path}');
    if (!await file.exists()) {
      logger.info('Database file does not exist, creating new database');
      await file.create(recursive: true);
    } else {
      logger.info('Database exists at: ${file.path}');
    }
    return NativeDatabase.createInBackground(file);
  });
}

// --- FILE BREAK ---

// File: lib/data/database.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $MedicationsTable extends Medications
    with TableInfo<$MedicationsTable, Medication> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MedicationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _concentrationMeta = const VerificationMeta(
    'concentration',
  );
  @override
  late final GeneratedColumn<double> concentration = GeneratedColumn<double>(
    'concentration',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _concentrationUnitMeta = const VerificationMeta(
    'concentrationUnit',
  );
  @override
  late final GeneratedColumn<String> concentrationUnit =
      GeneratedColumn<String>(
        'concentration_unit',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _stockQuantityMeta = const VerificationMeta(
    'stockQuantity',
  );
  @override
  late final GeneratedColumn<double> stockQuantity = GeneratedColumn<double>(
    'stock_quantity',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _formMeta = const VerificationMeta('form');
  @override
  late final GeneratedColumn<String> form = GeneratedColumn<String>(
    'form',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    concentration,
    concentrationUnit,
    stockQuantity,
    form,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'medications';
  @override
  VerificationContext validateIntegrity(
    Insertable<Medication> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('concentration')) {
      context.handle(
        _concentrationMeta,
        concentration.isAcceptableOrUnknown(
          data['concentration']!,
          _concentrationMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_concentrationMeta);
    }
    if (data.containsKey('concentration_unit')) {
      context.handle(
        _concentrationUnitMeta,
        concentrationUnit.isAcceptableOrUnknown(
          data['concentration_unit']!,
          _concentrationUnitMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_concentrationUnitMeta);
    }
    if (data.containsKey('stock_quantity')) {
      context.handle(
        _stockQuantityMeta,
        stockQuantity.isAcceptableOrUnknown(
          data['stock_quantity']!,
          _stockQuantityMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_stockQuantityMeta);
    }
    if (data.containsKey('form')) {
      context.handle(
        _formMeta,
        form.isAcceptableOrUnknown(data['form']!, _formMeta),
      );
    } else if (isInserting) {
      context.missing(_formMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Medication map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Medication(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      concentration: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}concentration'],
      )!,
      concentrationUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}concentration_unit'],
      )!,
      stockQuantity: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}stock_quantity'],
      )!,
      form: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}form'],
      )!,
    );
  }

  @override
  $MedicationsTable createAlias(String alias) {
    return $MedicationsTable(attachedDatabase, alias);
  }
}

class Medication extends DataClass implements Insertable<Medication> {
  final int id;
  final String name;
  final double concentration;
  final String concentrationUnit;
  final double stockQuantity;
  final String form;
  const Medication({
    required this.id,
    required this.name,
    required this.concentration,
    required this.concentrationUnit,
    required this.stockQuantity,
    required this.form,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['concentration'] = Variable<double>(concentration);
    map['concentration_unit'] = Variable<String>(concentrationUnit);
    map['stock_quantity'] = Variable<double>(stockQuantity);
    map['form'] = Variable<String>(form);
    return map;
  }

  MedicationsCompanion toCompanion(bool nullToAbsent) {
    return MedicationsCompanion(
      id: Value(id),
      name: Value(name),
      concentration: Value(concentration),
      concentrationUnit: Value(concentrationUnit),
      stockQuantity: Value(stockQuantity),
      form: Value(form),
    );
  }

  factory Medication.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Medication(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      concentration: serializer.fromJson<double>(json['concentration']),
      concentrationUnit: serializer.fromJson<String>(json['concentrationUnit']),
      stockQuantity: serializer.fromJson<double>(json['stockQuantity']),
      form: serializer.fromJson<String>(json['form']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'concentration': serializer.toJson<double>(concentration),
      'concentrationUnit': serializer.toJson<String>(concentrationUnit),
      'stockQuantity': serializer.toJson<double>(stockQuantity),
      'form': serializer.toJson<String>(form),
    };
  }

  Medication copyWith({
    int? id,
    String? name,
    double? concentration,
    String? concentrationUnit,
    double? stockQuantity,
    String? form,
  }) => Medication(
    id: id ?? this.id,
    name: name ?? this.name,
    concentration: concentration ?? this.concentration,
    concentrationUnit: concentrationUnit ?? this.concentrationUnit,
    stockQuantity: stockQuantity ?? this.stockQuantity,
    form: form ?? this.form,
  );
  Medication copyWithCompanion(MedicationsCompanion data) {
    return Medication(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      concentration: data.concentration.present
          ? data.concentration.value
          : this.concentration,
      concentrationUnit: data.concentrationUnit.present
          ? data.concentrationUnit.value
          : this.concentrationUnit,
      stockQuantity: data.stockQuantity.present
          ? data.stockQuantity.value
          : this.stockQuantity,
      form: data.form.present ? data.form.value : this.form,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Medication(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('concentration: $concentration, ')
          ..write('concentrationUnit: $concentrationUnit, ')
          ..write('stockQuantity: $stockQuantity, ')
          ..write('form: $form')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    concentration,
    concentrationUnit,
    stockQuantity,
    form,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Medication &&
          other.id == this.id &&
          other.name == this.name &&
          other.concentration == this.concentration &&
          other.concentrationUnit == this.concentrationUnit &&
          other.stockQuantity == this.stockQuantity &&
          other.form == this.form);
}

class MedicationsCompanion extends UpdateCompanion<Medication> {
  final Value<int> id;
  final Value<String> name;
  final Value<double> concentration;
  final Value<String> concentrationUnit;
  final Value<double> stockQuantity;
  final Value<String> form;
  const MedicationsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.concentration = const Value.absent(),
    this.concentrationUnit = const Value.absent(),
    this.stockQuantity = const Value.absent(),
    this.form = const Value.absent(),
  });
  MedicationsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required double concentration,
    required String concentrationUnit,
    required double stockQuantity,
    required String form,
  }) : name = Value(name),
       concentration = Value(concentration),
       concentrationUnit = Value(concentrationUnit),
       stockQuantity = Value(stockQuantity),
       form = Value(form);
  static Insertable<Medication> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<double>? concentration,
    Expression<String>? concentrationUnit,
    Expression<double>? stockQuantity,
    Expression<String>? form,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (concentration != null) 'concentration': concentration,
      if (concentrationUnit != null) 'concentration_unit': concentrationUnit,
      if (stockQuantity != null) 'stock_quantity': stockQuantity,
      if (form != null) 'form': form,
    });
  }

  MedicationsCompanion copyWith({
    Value<int>? id,
    Value<String>? name,
    Value<double>? concentration,
    Value<String>? concentrationUnit,
    Value<double>? stockQuantity,
    Value<String>? form,
  }) {
    return MedicationsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      concentration: concentration ?? this.concentration,
      concentrationUnit: concentrationUnit ?? this.concentrationUnit,
      stockQuantity: stockQuantity ?? this.stockQuantity,
      form: form ?? this.form,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (concentration.present) {
      map['concentration'] = Variable<double>(concentration.value);
    }
    if (concentrationUnit.present) {
      map['concentration_unit'] = Variable<String>(concentrationUnit.value);
    }
    if (stockQuantity.present) {
      map['stock_quantity'] = Variable<double>(stockQuantity.value);
    }
    if (form.present) {
      map['form'] = Variable<String>(form.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MedicationsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('concentration: $concentration, ')
          ..write('concentrationUnit: $concentrationUnit, ')
          ..write('stockQuantity: $stockQuantity, ')
          ..write('form: $form')
          ..write(')'))
        .toString();
  }
}

class $DosesTable extends Doses with TableInfo<$DosesTable, Dose> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DosesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _medicationIdMeta = const VerificationMeta(
    'medicationId',
  );
  @override
  late final GeneratedColumn<int> medicationId = GeneratedColumn<int>(
    'medication_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES medications (id)',
    ),
  );
  static const VerificationMeta _medicationNameMeta = const VerificationMeta(
    'medicationName',
  );
  @override
  late final GeneratedColumn<String> medicationName = GeneratedColumn<String>(
    'medication_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
    'unit',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timeMeta = const VerificationMeta('time');
  @override
  late final GeneratedColumn<DateTime> time = GeneratedColumn<DateTime>(
    'time',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _takenMeta = const VerificationMeta('taken');
  @override
  late final GeneratedColumn<bool> taken = GeneratedColumn<bool>(
    'taken',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("taken" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _weightMeta = const VerificationMeta('weight');
  @override
  late final GeneratedColumn<double> weight = GeneratedColumn<double>(
    'weight',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0.0),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    medicationId,
    medicationName,
    amount,
    unit,
    time,
    taken,
    weight,
    name,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'doses';
  @override
  VerificationContext validateIntegrity(
    Insertable<Dose> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('medication_id')) {
      context.handle(
        _medicationIdMeta,
        medicationId.isAcceptableOrUnknown(
          data['medication_id']!,
          _medicationIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_medicationIdMeta);
    }
    if (data.containsKey('medication_name')) {
      context.handle(
        _medicationNameMeta,
        medicationName.isAcceptableOrUnknown(
          data['medication_name']!,
          _medicationNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_medicationNameMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('unit')) {
      context.handle(
        _unitMeta,
        unit.isAcceptableOrUnknown(data['unit']!, _unitMeta),
      );
    } else if (isInserting) {
      context.missing(_unitMeta);
    }
    if (data.containsKey('time')) {
      context.handle(
        _timeMeta,
        time.isAcceptableOrUnknown(data['time']!, _timeMeta),
      );
    } else if (isInserting) {
      context.missing(_timeMeta);
    }
    if (data.containsKey('taken')) {
      context.handle(
        _takenMeta,
        taken.isAcceptableOrUnknown(data['taken']!, _takenMeta),
      );
    }
    if (data.containsKey('weight')) {
      context.handle(
        _weightMeta,
        weight.isAcceptableOrUnknown(data['weight']!, _weightMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Dose map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Dose(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      medicationId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}medication_id'],
      )!,
      medicationName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}medication_name'],
      )!,
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}amount'],
      )!,
      unit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}unit'],
      )!,
      time: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}time'],
      )!,
      taken: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}taken'],
      )!,
      weight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}weight'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
    );
  }

  @override
  $DosesTable createAlias(String alias) {
    return $DosesTable(attachedDatabase, alias);
  }
}

class Dose extends DataClass implements Insertable<Dose> {
  final int id;
  final int medicationId;
  final String medicationName;
  final double amount;
  final String unit;
  final DateTime time;
  final bool taken;
  final double weight;
  final String? name;
  const Dose({
    required this.id,
    required this.medicationId,
    required this.medicationName,
    required this.amount,
    required this.unit,
    required this.time,
    required this.taken,
    required this.weight,
    this.name,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['medication_id'] = Variable<int>(medicationId);
    map['medication_name'] = Variable<String>(medicationName);
    map['amount'] = Variable<double>(amount);
    map['unit'] = Variable<String>(unit);
    map['time'] = Variable<DateTime>(time);
    map['taken'] = Variable<bool>(taken);
    map['weight'] = Variable<double>(weight);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    return map;
  }

  DosesCompanion toCompanion(bool nullToAbsent) {
    return DosesCompanion(
      id: Value(id),
      medicationId: Value(medicationId),
      medicationName: Value(medicationName),
      amount: Value(amount),
      unit: Value(unit),
      time: Value(time),
      taken: Value(taken),
      weight: Value(weight),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
    );
  }

  factory Dose.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Dose(
      id: serializer.fromJson<int>(json['id']),
      medicationId: serializer.fromJson<int>(json['medicationId']),
      medicationName: serializer.fromJson<String>(json['medicationName']),
      amount: serializer.fromJson<double>(json['amount']),
      unit: serializer.fromJson<String>(json['unit']),
      time: serializer.fromJson<DateTime>(json['time']),
      taken: serializer.fromJson<bool>(json['taken']),
      weight: serializer.fromJson<double>(json['weight']),
      name: serializer.fromJson<String?>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'medicationId': serializer.toJson<int>(medicationId),
      'medicationName': serializer.toJson<String>(medicationName),
      'amount': serializer.toJson<double>(amount),
      'unit': serializer.toJson<String>(unit),
      'time': serializer.toJson<DateTime>(time),
      'taken': serializer.toJson<bool>(taken),
      'weight': serializer.toJson<double>(weight),
      'name': serializer.toJson<String?>(name),
    };
  }

  Dose copyWith({
    int? id,
    int? medicationId,
    String? medicationName,
    double? amount,
    String? unit,
    DateTime? time,
    bool? taken,
    double? weight,
    Value<String?> name = const Value.absent(),
  }) => Dose(
    id: id ?? this.id,
    medicationId: medicationId ?? this.medicationId,
    medicationName: medicationName ?? this.medicationName,
    amount: amount ?? this.amount,
    unit: unit ?? this.unit,
    time: time ?? this.time,
    taken: taken ?? this.taken,
    weight: weight ?? this.weight,
    name: name.present ? name.value : this.name,
  );
  Dose copyWithCompanion(DosesCompanion data) {
    return Dose(
      id: data.id.present ? data.id.value : this.id,
      medicationId: data.medicationId.present
          ? data.medicationId.value
          : this.medicationId,
      medicationName: data.medicationName.present
          ? data.medicationName.value
          : this.medicationName,
      amount: data.amount.present ? data.amount.value : this.amount,
      unit: data.unit.present ? data.unit.value : this.unit,
      time: data.time.present ? data.time.value : this.time,
      taken: data.taken.present ? data.taken.value : this.taken,
      weight: data.weight.present ? data.weight.value : this.weight,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Dose(')
          ..write('id: $id, ')
          ..write('medicationId: $medicationId, ')
          ..write('medicationName: $medicationName, ')
          ..write('amount: $amount, ')
          ..write('unit: $unit, ')
          ..write('time: $time, ')
          ..write('taken: $taken, ')
          ..write('weight: $weight, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    medicationId,
    medicationName,
    amount,
    unit,
    time,
    taken,
    weight,
    name,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Dose &&
          other.id == this.id &&
          other.medicationId == this.medicationId &&
          other.medicationName == this.medicationName &&
          other.amount == this.amount &&
          other.unit == this.unit &&
          other.time == this.time &&
          other.taken == this.taken &&
          other.weight == this.weight &&
          other.name == this.name);
}

class DosesCompanion extends UpdateCompanion<Dose> {
  final Value<int> id;
  final Value<int> medicationId;
  final Value<String> medicationName;
  final Value<double> amount;
  final Value<String> unit;
  final Value<DateTime> time;
  final Value<bool> taken;
  final Value<double> weight;
  final Value<String?> name;
  const DosesCompanion({
    this.id = const Value.absent(),
    this.medicationId = const Value.absent(),
    this.medicationName = const Value.absent(),
    this.amount = const Value.absent(),
    this.unit = const Value.absent(),
    this.time = const Value.absent(),
    this.taken = const Value.absent(),
    this.weight = const Value.absent(),
    this.name = const Value.absent(),
  });
  DosesCompanion.insert({
    this.id = const Value.absent(),
    required int medicationId,
    required String medicationName,
    required double amount,
    required String unit,
    required DateTime time,
    this.taken = const Value.absent(),
    this.weight = const Value.absent(),
    this.name = const Value.absent(),
  }) : medicationId = Value(medicationId),
       medicationName = Value(medicationName),
       amount = Value(amount),
       unit = Value(unit),
       time = Value(time);
  static Insertable<Dose> custom({
    Expression<int>? id,
    Expression<int>? medicationId,
    Expression<String>? medicationName,
    Expression<double>? amount,
    Expression<String>? unit,
    Expression<DateTime>? time,
    Expression<bool>? taken,
    Expression<double>? weight,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (medicationId != null) 'medication_id': medicationId,
      if (medicationName != null) 'medication_name': medicationName,
      if (amount != null) 'amount': amount,
      if (unit != null) 'unit': unit,
      if (time != null) 'time': time,
      if (taken != null) 'taken': taken,
      if (weight != null) 'weight': weight,
      if (name != null) 'name': name,
    });
  }

  DosesCompanion copyWith({
    Value<int>? id,
    Value<int>? medicationId,
    Value<String>? medicationName,
    Value<double>? amount,
    Value<String>? unit,
    Value<DateTime>? time,
    Value<bool>? taken,
    Value<double>? weight,
    Value<String?>? name,
  }) {
    return DosesCompanion(
      id: id ?? this.id,
      medicationId: medicationId ?? this.medicationId,
      medicationName: medicationName ?? this.medicationName,
      amount: amount ?? this.amount,
      unit: unit ?? this.unit,
      time: time ?? this.time,
      taken: taken ?? this.taken,
      weight: weight ?? this.weight,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (medicationId.present) {
      map['medication_id'] = Variable<int>(medicationId.value);
    }
    if (medicationName.present) {
      map['medication_name'] = Variable<String>(medicationName.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (time.present) {
      map['time'] = Variable<DateTime>(time.value);
    }
    if (taken.present) {
      map['taken'] = Variable<bool>(taken.value);
    }
    if (weight.present) {
      map['weight'] = Variable<double>(weight.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DosesCompanion(')
          ..write('id: $id, ')
          ..write('medicationId: $medicationId, ')
          ..write('medicationName: $medicationName, ')
          ..write('amount: $amount, ')
          ..write('unit: $unit, ')
          ..write('time: $time, ')
          ..write('taken: $taken, ')
          ..write('weight: $weight, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $SchedulesTable extends Schedules
    with TableInfo<$SchedulesTable, Schedule> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SchedulesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _medicationIdMeta = const VerificationMeta(
    'medicationId',
  );
  @override
  late final GeneratedColumn<int> medicationId = GeneratedColumn<int>(
    'medication_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES medications (id)',
    ),
  );
  static const VerificationMeta _medicationNameMeta = const VerificationMeta(
    'medicationName',
  );
  @override
  late final GeneratedColumn<String> medicationName = GeneratedColumn<String>(
    'medication_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _doseIdMeta = const VerificationMeta('doseId');
  @override
  late final GeneratedColumn<int> doseId = GeneratedColumn<int>(
    'dose_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES doses (id)',
    ),
  );
  static const VerificationMeta _frequencyMeta = const VerificationMeta(
    'frequency',
  );
  @override
  late final GeneratedColumn<String> frequency = GeneratedColumn<String>(
    'frequency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  late final GeneratedColumnWithTypeConverter<List<String>, String> days =
      GeneratedColumn<String>(
        'days',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
      ).withConverter<List<String>>($SchedulesTable.$converterdays);
  static const VerificationMeta _timeMeta = const VerificationMeta('time');
  @override
  late final GeneratedColumn<DateTime> time = GeneratedColumn<DateTime>(
    'time',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _notificationsEnabledMeta =
      const VerificationMeta('notificationsEnabled');
  @override
  late final GeneratedColumn<bool> notificationsEnabled = GeneratedColumn<bool>(
    'notifications_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("notifications_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _notificationIdMeta = const VerificationMeta(
    'notificationId',
  );
  @override
  late final GeneratedColumn<String> notificationId = GeneratedColumn<String>(
    'notification_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    medicationId,
    medicationName,
    doseId,
    frequency,
    days,
    time,
    name,
    notificationsEnabled,
    notificationId,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'schedules';
  @override
  VerificationContext validateIntegrity(
    Insertable<Schedule> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('medication_id')) {
      context.handle(
        _medicationIdMeta,
        medicationId.isAcceptableOrUnknown(
          data['medication_id']!,
          _medicationIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_medicationIdMeta);
    }
    if (data.containsKey('medication_name')) {
      context.handle(
        _medicationNameMeta,
        medicationName.isAcceptableOrUnknown(
          data['medication_name']!,
          _medicationNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_medicationNameMeta);
    }
    if (data.containsKey('dose_id')) {
      context.handle(
        _doseIdMeta,
        doseId.isAcceptableOrUnknown(data['dose_id']!, _doseIdMeta),
      );
    }
    if (data.containsKey('frequency')) {
      context.handle(
        _frequencyMeta,
        frequency.isAcceptableOrUnknown(data['frequency']!, _frequencyMeta),
      );
    } else if (isInserting) {
      context.missing(_frequencyMeta);
    }
    if (data.containsKey('time')) {
      context.handle(
        _timeMeta,
        time.isAcceptableOrUnknown(data['time']!, _timeMeta),
      );
    } else if (isInserting) {
      context.missing(_timeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('notifications_enabled')) {
      context.handle(
        _notificationsEnabledMeta,
        notificationsEnabled.isAcceptableOrUnknown(
          data['notifications_enabled']!,
          _notificationsEnabledMeta,
        ),
      );
    }
    if (data.containsKey('notification_id')) {
      context.handle(
        _notificationIdMeta,
        notificationId.isAcceptableOrUnknown(
          data['notification_id']!,
          _notificationIdMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Schedule map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Schedule(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      medicationId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}medication_id'],
      )!,
      medicationName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}medication_name'],
      )!,
      doseId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}dose_id'],
      ),
      frequency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}frequency'],
      )!,
      days: $SchedulesTable.$converterdays.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}days'],
        )!,
      ),
      time: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}time'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      notificationsEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}notifications_enabled'],
      )!,
      notificationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notification_id'],
      ),
    );
  }

  @override
  $SchedulesTable createAlias(String alias) {
    return $SchedulesTable(attachedDatabase, alias);
  }

  static TypeConverter<List<String>, String> $converterdays =
      const StringListConverter();
}

class Schedule extends DataClass implements Insertable<Schedule> {
  final int id;
  final int medicationId;
  final String medicationName;
  final int? doseId;
  final String frequency;
  final List<String> days;
  final DateTime time;
  final String name;
  final bool notificationsEnabled;
  final String? notificationId;
  const Schedule({
    required this.id,
    required this.medicationId,
    required this.medicationName,
    this.doseId,
    required this.frequency,
    required this.days,
    required this.time,
    required this.name,
    required this.notificationsEnabled,
    this.notificationId,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['medication_id'] = Variable<int>(medicationId);
    map['medication_name'] = Variable<String>(medicationName);
    if (!nullToAbsent || doseId != null) {
      map['dose_id'] = Variable<int>(doseId);
    }
    map['frequency'] = Variable<String>(frequency);
    {
      map['days'] = Variable<String>(
        $SchedulesTable.$converterdays.toSql(days),
      );
    }
    map['time'] = Variable<DateTime>(time);
    map['name'] = Variable<String>(name);
    map['notifications_enabled'] = Variable<bool>(notificationsEnabled);
    if (!nullToAbsent || notificationId != null) {
      map['notification_id'] = Variable<String>(notificationId);
    }
    return map;
  }

  SchedulesCompanion toCompanion(bool nullToAbsent) {
    return SchedulesCompanion(
      id: Value(id),
      medicationId: Value(medicationId),
      medicationName: Value(medicationName),
      doseId: doseId == null && nullToAbsent
          ? const Value.absent()
          : Value(doseId),
      frequency: Value(frequency),
      days: Value(days),
      time: Value(time),
      name: Value(name),
      notificationsEnabled: Value(notificationsEnabled),
      notificationId: notificationId == null && nullToAbsent
          ? const Value.absent()
          : Value(notificationId),
    );
  }

  factory Schedule.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Schedule(
      id: serializer.fromJson<int>(json['id']),
      medicationId: serializer.fromJson<int>(json['medicationId']),
      medicationName: serializer.fromJson<String>(json['medicationName']),
      doseId: serializer.fromJson<int?>(json['doseId']),
      frequency: serializer.fromJson<String>(json['frequency']),
      days: serializer.fromJson<List<String>>(json['days']),
      time: serializer.fromJson<DateTime>(json['time']),
      name: serializer.fromJson<String>(json['name']),
      notificationsEnabled: serializer.fromJson<bool>(
        json['notificationsEnabled'],
      ),
      notificationId: serializer.fromJson<String?>(json['notificationId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'medicationId': serializer.toJson<int>(medicationId),
      'medicationName': serializer.toJson<String>(medicationName),
      'doseId': serializer.toJson<int?>(doseId),
      'frequency': serializer.toJson<String>(frequency),
      'days': serializer.toJson<List<String>>(days),
      'time': serializer.toJson<DateTime>(time),
      'name': serializer.toJson<String>(name),
      'notificationsEnabled': serializer.toJson<bool>(notificationsEnabled),
      'notificationId': serializer.toJson<String?>(notificationId),
    };
  }

  Schedule copyWith({
    int? id,
    int? medicationId,
    String? medicationName,
    Value<int?> doseId = const Value.absent(),
    String? frequency,
    List<String>? days,
    DateTime? time,
    String? name,
    bool? notificationsEnabled,
    Value<String?> notificationId = const Value.absent(),
  }) => Schedule(
    id: id ?? this.id,
    medicationId: medicationId ?? this.medicationId,
    medicationName: medicationName ?? this.medicationName,
    doseId: doseId.present ? doseId.value : this.doseId,
    frequency: frequency ?? this.frequency,
    days: days ?? this.days,
    time: time ?? this.time,
    name: name ?? this.name,
    notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
    notificationId: notificationId.present
        ? notificationId.value
        : this.notificationId,
  );
  Schedule copyWithCompanion(SchedulesCompanion data) {
    return Schedule(
      id: data.id.present ? data.id.value : this.id,
      medicationId: data.medicationId.present
          ? data.medicationId.value
          : this.medicationId,
      medicationName: data.medicationName.present
          ? data.medicationName.value
          : this.medicationName,
      doseId: data.doseId.present ? data.doseId.value : this.doseId,
      frequency: data.frequency.present ? data.frequency.value : this.frequency,
      days: data.days.present ? data.days.value : this.days,
      time: data.time.present ? data.time.value : this.time,
      name: data.name.present ? data.name.value : this.name,
      notificationsEnabled: data.notificationsEnabled.present
          ? data.notificationsEnabled.value
          : this.notificationsEnabled,
      notificationId: data.notificationId.present
          ? data.notificationId.value
          : this.notificationId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Schedule(')
          ..write('id: $id, ')
          ..write('medicationId: $medicationId, ')
          ..write('medicationName: $medicationName, ')
          ..write('doseId: $doseId, ')
          ..write('frequency: $frequency, ')
          ..write('days: $days, ')
          ..write('time: $time, ')
          ..write('name: $name, ')
          ..write('notificationsEnabled: $notificationsEnabled, ')
          ..write('notificationId: $notificationId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    medicationId,
    medicationName,
    doseId,
    frequency,
    days,
    time,
    name,
    notificationsEnabled,
    notificationId,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Schedule &&
          other.id == this.id &&
          other.medicationId == this.medicationId &&
          other.medicationName == this.medicationName &&
          other.doseId == this.doseId &&
          other.frequency == this.frequency &&
          other.days == this.days &&
          other.time == this.time &&
          other.name == this.name &&
          other.notificationsEnabled == this.notificationsEnabled &&
          other.notificationId == this.notificationId);
}

class SchedulesCompanion extends UpdateCompanion<Schedule> {
  final Value<int> id;
  final Value<int> medicationId;
  final Value<String> medicationName;
  final Value<int?> doseId;
  final Value<String> frequency;
  final Value<List<String>> days;
  final Value<DateTime> time;
  final Value<String> name;
  final Value<bool> notificationsEnabled;
  final Value<String?> notificationId;
  const SchedulesCompanion({
    this.id = const Value.absent(),
    this.medicationId = const Value.absent(),
    this.medicationName = const Value.absent(),
    this.doseId = const Value.absent(),
    this.frequency = const Value.absent(),
    this.days = const Value.absent(),
    this.time = const Value.absent(),
    this.name = const Value.absent(),
    this.notificationsEnabled = const Value.absent(),
    this.notificationId = const Value.absent(),
  });
  SchedulesCompanion.insert({
    this.id = const Value.absent(),
    required int medicationId,
    required String medicationName,
    this.doseId = const Value.absent(),
    required String frequency,
    required List<String> days,
    required DateTime time,
    this.name = const Value.absent(),
    this.notificationsEnabled = const Value.absent(),
    this.notificationId = const Value.absent(),
  }) : medicationId = Value(medicationId),
       medicationName = Value(medicationName),
       frequency = Value(frequency),
       days = Value(days),
       time = Value(time);
  static Insertable<Schedule> custom({
    Expression<int>? id,
    Expression<int>? medicationId,
    Expression<String>? medicationName,
    Expression<int>? doseId,
    Expression<String>? frequency,
    Expression<String>? days,
    Expression<DateTime>? time,
    Expression<String>? name,
    Expression<bool>? notificationsEnabled,
    Expression<String>? notificationId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (medicationId != null) 'medication_id': medicationId,
      if (medicationName != null) 'medication_name': medicationName,
      if (doseId != null) 'dose_id': doseId,
      if (frequency != null) 'frequency': frequency,
      if (days != null) 'days': days,
      if (time != null) 'time': time,
      if (name != null) 'name': name,
      if (notificationsEnabled != null)
        'notifications_enabled': notificationsEnabled,
      if (notificationId != null) 'notification_id': notificationId,
    });
  }

  SchedulesCompanion copyWith({
    Value<int>? id,
    Value<int>? medicationId,
    Value<String>? medicationName,
    Value<int?>? doseId,
    Value<String>? frequency,
    Value<List<String>>? days,
    Value<DateTime>? time,
    Value<String>? name,
    Value<bool>? notificationsEnabled,
    Value<String?>? notificationId,
  }) {
    return SchedulesCompanion(
      id: id ?? this.id,
      medicationId: medicationId ?? this.medicationId,
      medicationName: medicationName ?? this.medicationName,
      doseId: doseId ?? this.doseId,
      frequency: frequency ?? this.frequency,
      days: days ?? this.days,
      time: time ?? this.time,
      name: name ?? this.name,
      notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
      notificationId: notificationId ?? this.notificationId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (medicationId.present) {
      map['medication_id'] = Variable<int>(medicationId.value);
    }
    if (medicationName.present) {
      map['medication_name'] = Variable<String>(medicationName.value);
    }
    if (doseId.present) {
      map['dose_id'] = Variable<int>(doseId.value);
    }
    if (frequency.present) {
      map['frequency'] = Variable<String>(frequency.value);
    }
    if (days.present) {
      map['days'] = Variable<String>(
        $SchedulesTable.$converterdays.toSql(days.value),
      );
    }
    if (time.present) {
      map['time'] = Variable<DateTime>(time.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (notificationsEnabled.present) {
      map['notifications_enabled'] = Variable<bool>(notificationsEnabled.value);
    }
    if (notificationId.present) {
      map['notification_id'] = Variable<String>(notificationId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SchedulesCompanion(')
          ..write('id: $id, ')
          ..write('medicationId: $medicationId, ')
          ..write('medicationName: $medicationName, ')
          ..write('doseId: $doseId, ')
          ..write('frequency: $frequency, ')
          ..write('days: $days, ')
          ..write('time: $time, ')
          ..write('name: $name, ')
          ..write('notificationsEnabled: $notificationsEnabled, ')
          ..write('notificationId: $notificationId')
          ..write(')'))
        .toString();
  }
}

class $DoseHistoryTable extends DoseHistory
    with TableInfo<$DoseHistoryTable, DoseHistoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DoseHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _doseIdMeta = const VerificationMeta('doseId');
  @override
  late final GeneratedColumn<int> doseId = GeneratedColumn<int>(
    'dose_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES doses (id)',
    ),
  );
  static const VerificationMeta _takenAtMeta = const VerificationMeta(
    'takenAt',
  );
  @override
  late final GeneratedColumn<DateTime> takenAt = GeneratedColumn<DateTime>(
    'taken_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [id, doseId, takenAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'dose_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<DoseHistoryData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('dose_id')) {
      context.handle(
        _doseIdMeta,
        doseId.isAcceptableOrUnknown(data['dose_id']!, _doseIdMeta),
      );
    } else if (isInserting) {
      context.missing(_doseIdMeta);
    }
    if (data.containsKey('taken_at')) {
      context.handle(
        _takenAtMeta,
        takenAt.isAcceptableOrUnknown(data['taken_at']!, _takenAtMeta),
      );
    } else if (isInserting) {
      context.missing(_takenAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DoseHistoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DoseHistoryData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      doseId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}dose_id'],
      )!,
      takenAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}taken_at'],
      )!,
    );
  }

  @override
  $DoseHistoryTable createAlias(String alias) {
    return $DoseHistoryTable(attachedDatabase, alias);
  }
}

class DoseHistoryData extends DataClass implements Insertable<DoseHistoryData> {
  final int id;
  final int doseId;
  final DateTime takenAt;
  const DoseHistoryData({
    required this.id,
    required this.doseId,
    required this.takenAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['dose_id'] = Variable<int>(doseId);
    map['taken_at'] = Variable<DateTime>(takenAt);
    return map;
  }

  DoseHistoryCompanion toCompanion(bool nullToAbsent) {
    return DoseHistoryCompanion(
      id: Value(id),
      doseId: Value(doseId),
      takenAt: Value(takenAt),
    );
  }

  factory DoseHistoryData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DoseHistoryData(
      id: serializer.fromJson<int>(json['id']),
      doseId: serializer.fromJson<int>(json['doseId']),
      takenAt: serializer.fromJson<DateTime>(json['takenAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'doseId': serializer.toJson<int>(doseId),
      'takenAt': serializer.toJson<DateTime>(takenAt),
    };
  }

  DoseHistoryData copyWith({int? id, int? doseId, DateTime? takenAt}) =>
      DoseHistoryData(
        id: id ?? this.id,
        doseId: doseId ?? this.doseId,
        takenAt: takenAt ?? this.takenAt,
      );
  DoseHistoryData copyWithCompanion(DoseHistoryCompanion data) {
    return DoseHistoryData(
      id: data.id.present ? data.id.value : this.id,
      doseId: data.doseId.present ? data.doseId.value : this.doseId,
      takenAt: data.takenAt.present ? data.takenAt.value : this.takenAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DoseHistoryData(')
          ..write('id: $id, ')
          ..write('doseId: $doseId, ')
          ..write('takenAt: $takenAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, doseId, takenAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DoseHistoryData &&
          other.id == this.id &&
          other.doseId == this.doseId &&
          other.takenAt == this.takenAt);
}

class DoseHistoryCompanion extends UpdateCompanion<DoseHistoryData> {
  final Value<int> id;
  final Value<int> doseId;
  final Value<DateTime> takenAt;
  const DoseHistoryCompanion({
    this.id = const Value.absent(),
    this.doseId = const Value.absent(),
    this.takenAt = const Value.absent(),
  });
  DoseHistoryCompanion.insert({
    this.id = const Value.absent(),
    required int doseId,
    required DateTime takenAt,
  }) : doseId = Value(doseId),
       takenAt = Value(takenAt);
  static Insertable<DoseHistoryData> custom({
    Expression<int>? id,
    Expression<int>? doseId,
    Expression<DateTime>? takenAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (doseId != null) 'dose_id': doseId,
      if (takenAt != null) 'taken_at': takenAt,
    });
  }

  DoseHistoryCompanion copyWith({
    Value<int>? id,
    Value<int>? doseId,
    Value<DateTime>? takenAt,
  }) {
    return DoseHistoryCompanion(
      id: id ?? this.id,
      doseId: doseId ?? this.doseId,
      takenAt: takenAt ?? this.takenAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (doseId.present) {
      map['dose_id'] = Variable<int>(doseId.value);
    }
    if (takenAt.present) {
      map['taken_at'] = Variable<DateTime>(takenAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DoseHistoryCompanion(')
          ..write('id: $id, ')
          ..write('doseId: $doseId, ')
          ..write('takenAt: $takenAt')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $MedicationsTable medications = $MedicationsTable(this);
  late final $DosesTable doses = $DosesTable(this);
  late final $SchedulesTable schedules = $SchedulesTable(this);
  late final $DoseHistoryTable doseHistory = $DoseHistoryTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    medications,
    doses,
    schedules,
    doseHistory,
  ];
}

typedef $$MedicationsTableCreateCompanionBuilder =
    MedicationsCompanion Function({
      Value<int> id,
      required String name,
      required double concentration,
      required String concentrationUnit,
      required double stockQuantity,
      required String form,
    });
typedef $$MedicationsTableUpdateCompanionBuilder =
    MedicationsCompanion Function({
      Value<int> id,
      Value<String> name,
      Value<double> concentration,
      Value<String> concentrationUnit,
      Value<double> stockQuantity,
      Value<String> form,
    });

final class $$MedicationsTableReferences
    extends BaseReferences<_$AppDatabase, $MedicationsTable, Medication> {
  $$MedicationsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$DosesTable, List<Dose>> _dosesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.doses,
    aliasName: $_aliasNameGenerator(db.medications.id, db.doses.medicationId),
  );

  $$DosesTableProcessedTableManager get dosesRefs {
    final manager = $$DosesTableTableManager(
      $_db,
      $_db.doses,
    ).filter((f) => f.medicationId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_dosesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SchedulesTable, List<Schedule>>
  _schedulesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.schedules,
    aliasName: $_aliasNameGenerator(
      db.medications.id,
      db.schedules.medicationId,
    ),
  );

  $$SchedulesTableProcessedTableManager get schedulesRefs {
    final manager = $$SchedulesTableTableManager(
      $_db,
      $_db.schedules,
    ).filter((f) => f.medicationId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_schedulesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$MedicationsTableFilterComposer
    extends Composer<_$AppDatabase, $MedicationsTable> {
  $$MedicationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get concentration => $composableBuilder(
    column: $table.concentration,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get concentrationUnit => $composableBuilder(
    column: $table.concentrationUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get stockQuantity => $composableBuilder(
    column: $table.stockQuantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get form => $composableBuilder(
    column: $table.form,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> dosesRefs(
    Expression<bool> Function($$DosesTableFilterComposer f) f,
  ) {
    final $$DosesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.doses,
      getReferencedColumn: (t) => t.medicationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DosesTableFilterComposer(
            $db: $db,
            $table: $db.doses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> schedulesRefs(
    Expression<bool> Function($$SchedulesTableFilterComposer f) f,
  ) {
    final $$SchedulesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.schedules,
      getReferencedColumn: (t) => t.medicationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SchedulesTableFilterComposer(
            $db: $db,
            $table: $db.schedules,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$MedicationsTableOrderingComposer
    extends Composer<_$AppDatabase, $MedicationsTable> {
  $$MedicationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get concentration => $composableBuilder(
    column: $table.concentration,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get concentrationUnit => $composableBuilder(
    column: $table.concentrationUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get stockQuantity => $composableBuilder(
    column: $table.stockQuantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get form => $composableBuilder(
    column: $table.form,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MedicationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $MedicationsTable> {
  $$MedicationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get concentration => $composableBuilder(
    column: $table.concentration,
    builder: (column) => column,
  );

  GeneratedColumn<String> get concentrationUnit => $composableBuilder(
    column: $table.concentrationUnit,
    builder: (column) => column,
  );

  GeneratedColumn<double> get stockQuantity => $composableBuilder(
    column: $table.stockQuantity,
    builder: (column) => column,
  );

  GeneratedColumn<String> get form =>
      $composableBuilder(column: $table.form, builder: (column) => column);

  Expression<T> dosesRefs<T extends Object>(
    Expression<T> Function($$DosesTableAnnotationComposer a) f,
  ) {
    final $$DosesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.doses,
      getReferencedColumn: (t) => t.medicationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DosesTableAnnotationComposer(
            $db: $db,
            $table: $db.doses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> schedulesRefs<T extends Object>(
    Expression<T> Function($$SchedulesTableAnnotationComposer a) f,
  ) {
    final $$SchedulesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.schedules,
      getReferencedColumn: (t) => t.medicationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SchedulesTableAnnotationComposer(
            $db: $db,
            $table: $db.schedules,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$MedicationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MedicationsTable,
          Medication,
          $$MedicationsTableFilterComposer,
          $$MedicationsTableOrderingComposer,
          $$MedicationsTableAnnotationComposer,
          $$MedicationsTableCreateCompanionBuilder,
          $$MedicationsTableUpdateCompanionBuilder,
          (Medication, $$MedicationsTableReferences),
          Medication,
          PrefetchHooks Function({bool dosesRefs, bool schedulesRefs})
        > {
  $$MedicationsTableTableManager(_$AppDatabase db, $MedicationsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MedicationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MedicationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MedicationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<double> concentration = const Value.absent(),
                Value<String> concentrationUnit = const Value.absent(),
                Value<double> stockQuantity = const Value.absent(),
                Value<String> form = const Value.absent(),
              }) => MedicationsCompanion(
                id: id,
                name: name,
                concentration: concentration,
                concentrationUnit: concentrationUnit,
                stockQuantity: stockQuantity,
                form: form,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String name,
                required double concentration,
                required String concentrationUnit,
                required double stockQuantity,
                required String form,
              }) => MedicationsCompanion.insert(
                id: id,
                name: name,
                concentration: concentration,
                concentrationUnit: concentrationUnit,
                stockQuantity: stockQuantity,
                form: form,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$MedicationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({dosesRefs = false, schedulesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (dosesRefs) db.doses,
                if (schedulesRefs) db.schedules,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (dosesRefs)
                    await $_getPrefetchedData<
                      Medication,
                      $MedicationsTable,
                      Dose
                    >(
                      currentTable: table,
                      referencedTable: $$MedicationsTableReferences
                          ._dosesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$MedicationsTableReferences(db, table, p0).dosesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.medicationId == item.id,
                          ),
                      typedResults: items,
                    ),
                  if (schedulesRefs)
                    await $_getPrefetchedData<
                      Medication,
                      $MedicationsTable,
                      Schedule
                    >(
                      currentTable: table,
                      referencedTable: $$MedicationsTableReferences
                          ._schedulesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$MedicationsTableReferences(
                            db,
                            table,
                            p0,
                          ).schedulesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.medicationId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$MedicationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MedicationsTable,
      Medication,
      $$MedicationsTableFilterComposer,
      $$MedicationsTableOrderingComposer,
      $$MedicationsTableAnnotationComposer,
      $$MedicationsTableCreateCompanionBuilder,
      $$MedicationsTableUpdateCompanionBuilder,
      (Medication, $$MedicationsTableReferences),
      Medication,
      PrefetchHooks Function({bool dosesRefs, bool schedulesRefs})
    >;
typedef $$DosesTableCreateCompanionBuilder =
    DosesCompanion Function({
      Value<int> id,
      required int medicationId,
      required String medicationName,
      required double amount,
      required String unit,
      required DateTime time,
      Value<bool> taken,
      Value<double> weight,
      Value<String?> name,
    });
typedef $$DosesTableUpdateCompanionBuilder =
    DosesCompanion Function({
      Value<int> id,
      Value<int> medicationId,
      Value<String> medicationName,
      Value<double> amount,
      Value<String> unit,
      Value<DateTime> time,
      Value<bool> taken,
      Value<double> weight,
      Value<String?> name,
    });

final class $$DosesTableReferences
    extends BaseReferences<_$AppDatabase, $DosesTable, Dose> {
  $$DosesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $MedicationsTable _medicationIdTable(_$AppDatabase db) =>
      db.medications.createAlias(
        $_aliasNameGenerator(db.doses.medicationId, db.medications.id),
      );

  $$MedicationsTableProcessedTableManager get medicationId {
    final $_column = $_itemColumn<int>('medication_id')!;

    final manager = $$MedicationsTableTableManager(
      $_db,
      $_db.medications,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_medicationIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$SchedulesTable, List<Schedule>>
  _schedulesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.schedules,
    aliasName: $_aliasNameGenerator(db.doses.id, db.schedules.doseId),
  );

  $$SchedulesTableProcessedTableManager get schedulesRefs {
    final manager = $$SchedulesTableTableManager(
      $_db,
      $_db.schedules,
    ).filter((f) => f.doseId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_schedulesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$DoseHistoryTable, List<DoseHistoryData>>
  _doseHistoryRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.doseHistory,
    aliasName: $_aliasNameGenerator(db.doses.id, db.doseHistory.doseId),
  );

  $$DoseHistoryTableProcessedTableManager get doseHistoryRefs {
    final manager = $$DoseHistoryTableTableManager(
      $_db,
      $_db.doseHistory,
    ).filter((f) => f.doseId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_doseHistoryRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$DosesTableFilterComposer extends Composer<_$AppDatabase, $DosesTable> {
  $$DosesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get medicationName => $composableBuilder(
    column: $table.medicationName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get time => $composableBuilder(
    column: $table.time,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get taken => $composableBuilder(
    column: $table.taken,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get weight => $composableBuilder(
    column: $table.weight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  $$MedicationsTableFilterComposer get medicationId {
    final $$MedicationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.medicationId,
      referencedTable: $db.medications,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MedicationsTableFilterComposer(
            $db: $db,
            $table: $db.medications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> schedulesRefs(
    Expression<bool> Function($$SchedulesTableFilterComposer f) f,
  ) {
    final $$SchedulesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.schedules,
      getReferencedColumn: (t) => t.doseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SchedulesTableFilterComposer(
            $db: $db,
            $table: $db.schedules,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> doseHistoryRefs(
    Expression<bool> Function($$DoseHistoryTableFilterComposer f) f,
  ) {
    final $$DoseHistoryTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.doseHistory,
      getReferencedColumn: (t) => t.doseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DoseHistoryTableFilterComposer(
            $db: $db,
            $table: $db.doseHistory,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$DosesTableOrderingComposer
    extends Composer<_$AppDatabase, $DosesTable> {
  $$DosesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get medicationName => $composableBuilder(
    column: $table.medicationName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get time => $composableBuilder(
    column: $table.time,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get taken => $composableBuilder(
    column: $table.taken,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get weight => $composableBuilder(
    column: $table.weight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  $$MedicationsTableOrderingComposer get medicationId {
    final $$MedicationsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.medicationId,
      referencedTable: $db.medications,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MedicationsTableOrderingComposer(
            $db: $db,
            $table: $db.medications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DosesTableAnnotationComposer
    extends Composer<_$AppDatabase, $DosesTable> {
  $$DosesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get medicationName => $composableBuilder(
    column: $table.medicationName,
    builder: (column) => column,
  );

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<DateTime> get time =>
      $composableBuilder(column: $table.time, builder: (column) => column);

  GeneratedColumn<bool> get taken =>
      $composableBuilder(column: $table.taken, builder: (column) => column);

  GeneratedColumn<double> get weight =>
      $composableBuilder(column: $table.weight, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  $$MedicationsTableAnnotationComposer get medicationId {
    final $$MedicationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.medicationId,
      referencedTable: $db.medications,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MedicationsTableAnnotationComposer(
            $db: $db,
            $table: $db.medications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> schedulesRefs<T extends Object>(
    Expression<T> Function($$SchedulesTableAnnotationComposer a) f,
  ) {
    final $$SchedulesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.schedules,
      getReferencedColumn: (t) => t.doseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SchedulesTableAnnotationComposer(
            $db: $db,
            $table: $db.schedules,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> doseHistoryRefs<T extends Object>(
    Expression<T> Function($$DoseHistoryTableAnnotationComposer a) f,
  ) {
    final $$DoseHistoryTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.doseHistory,
      getReferencedColumn: (t) => t.doseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DoseHistoryTableAnnotationComposer(
            $db: $db,
            $table: $db.doseHistory,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$DosesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DosesTable,
          Dose,
          $$DosesTableFilterComposer,
          $$DosesTableOrderingComposer,
          $$DosesTableAnnotationComposer,
          $$DosesTableCreateCompanionBuilder,
          $$DosesTableUpdateCompanionBuilder,
          (Dose, $$DosesTableReferences),
          Dose,
          PrefetchHooks Function({
            bool medicationId,
            bool schedulesRefs,
            bool doseHistoryRefs,
          })
        > {
  $$DosesTableTableManager(_$AppDatabase db, $DosesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DosesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DosesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DosesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> medicationId = const Value.absent(),
                Value<String> medicationName = const Value.absent(),
                Value<double> amount = const Value.absent(),
                Value<String> unit = const Value.absent(),
                Value<DateTime> time = const Value.absent(),
                Value<bool> taken = const Value.absent(),
                Value<double> weight = const Value.absent(),
                Value<String?> name = const Value.absent(),
              }) => DosesCompanion(
                id: id,
                medicationId: medicationId,
                medicationName: medicationName,
                amount: amount,
                unit: unit,
                time: time,
                taken: taken,
                weight: weight,
                name: name,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int medicationId,
                required String medicationName,
                required double amount,
                required String unit,
                required DateTime time,
                Value<bool> taken = const Value.absent(),
                Value<double> weight = const Value.absent(),
                Value<String?> name = const Value.absent(),
              }) => DosesCompanion.insert(
                id: id,
                medicationId: medicationId,
                medicationName: medicationName,
                amount: amount,
                unit: unit,
                time: time,
                taken: taken,
                weight: weight,
                name: name,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$DosesTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                medicationId = false,
                schedulesRefs = false,
                doseHistoryRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (schedulesRefs) db.schedules,
                    if (doseHistoryRefs) db.doseHistory,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (medicationId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.medicationId,
                                    referencedTable: $$DosesTableReferences
                                        ._medicationIdTable(db),
                                    referencedColumn: $$DosesTableReferences
                                        ._medicationIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (schedulesRefs)
                        await $_getPrefetchedData<Dose, $DosesTable, Schedule>(
                          currentTable: table,
                          referencedTable: $$DosesTableReferences
                              ._schedulesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$DosesTableReferences(
                                db,
                                table,
                                p0,
                              ).schedulesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.doseId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (doseHistoryRefs)
                        await $_getPrefetchedData<
                          Dose,
                          $DosesTable,
                          DoseHistoryData
                        >(
                          currentTable: table,
                          referencedTable: $$DosesTableReferences
                              ._doseHistoryRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$DosesTableReferences(
                                db,
                                table,
                                p0,
                              ).doseHistoryRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.doseId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$DosesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DosesTable,
      Dose,
      $$DosesTableFilterComposer,
      $$DosesTableOrderingComposer,
      $$DosesTableAnnotationComposer,
      $$DosesTableCreateCompanionBuilder,
      $$DosesTableUpdateCompanionBuilder,
      (Dose, $$DosesTableReferences),
      Dose,
      PrefetchHooks Function({
        bool medicationId,
        bool schedulesRefs,
        bool doseHistoryRefs,
      })
    >;
typedef $$SchedulesTableCreateCompanionBuilder =
    SchedulesCompanion Function({
      Value<int> id,
      required int medicationId,
      required String medicationName,
      Value<int?> doseId,
      required String frequency,
      required List<String> days,
      required DateTime time,
      Value<String> name,
      Value<bool> notificationsEnabled,
      Value<String?> notificationId,
    });
typedef $$SchedulesTableUpdateCompanionBuilder =
    SchedulesCompanion Function({
      Value<int> id,
      Value<int> medicationId,
      Value<String> medicationName,
      Value<int?> doseId,
      Value<String> frequency,
      Value<List<String>> days,
      Value<DateTime> time,
      Value<String> name,
      Value<bool> notificationsEnabled,
      Value<String?> notificationId,
    });

final class $$SchedulesTableReferences
    extends BaseReferences<_$AppDatabase, $SchedulesTable, Schedule> {
  $$SchedulesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $MedicationsTable _medicationIdTable(_$AppDatabase db) =>
      db.medications.createAlias(
        $_aliasNameGenerator(db.schedules.medicationId, db.medications.id),
      );

  $$MedicationsTableProcessedTableManager get medicationId {
    final $_column = $_itemColumn<int>('medication_id')!;

    final manager = $$MedicationsTableTableManager(
      $_db,
      $_db.medications,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_medicationIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $DosesTable _doseIdTable(_$AppDatabase db) => db.doses.createAlias(
    $_aliasNameGenerator(db.schedules.doseId, db.doses.id),
  );

  $$DosesTableProcessedTableManager? get doseId {
    final $_column = $_itemColumn<int>('dose_id');
    if ($_column == null) return null;
    final manager = $$DosesTableTableManager(
      $_db,
      $_db.doses,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_doseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SchedulesTableFilterComposer
    extends Composer<_$AppDatabase, $SchedulesTable> {
  $$SchedulesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get medicationName => $composableBuilder(
    column: $table.medicationName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get frequency => $composableBuilder(
    column: $table.frequency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<List<String>, List<String>, String> get days =>
      $composableBuilder(
        column: $table.days,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnFilters<DateTime> get time => $composableBuilder(
    column: $table.time,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get notificationsEnabled => $composableBuilder(
    column: $table.notificationsEnabled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notificationId => $composableBuilder(
    column: $table.notificationId,
    builder: (column) => ColumnFilters(column),
  );

  $$MedicationsTableFilterComposer get medicationId {
    final $$MedicationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.medicationId,
      referencedTable: $db.medications,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MedicationsTableFilterComposer(
            $db: $db,
            $table: $db.medications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DosesTableFilterComposer get doseId {
    final $$DosesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.doseId,
      referencedTable: $db.doses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DosesTableFilterComposer(
            $db: $db,
            $table: $db.doses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SchedulesTableOrderingComposer
    extends Composer<_$AppDatabase, $SchedulesTable> {
  $$SchedulesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get medicationName => $composableBuilder(
    column: $table.medicationName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get frequency => $composableBuilder(
    column: $table.frequency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get days => $composableBuilder(
    column: $table.days,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get time => $composableBuilder(
    column: $table.time,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get notificationsEnabled => $composableBuilder(
    column: $table.notificationsEnabled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notificationId => $composableBuilder(
    column: $table.notificationId,
    builder: (column) => ColumnOrderings(column),
  );

  $$MedicationsTableOrderingComposer get medicationId {
    final $$MedicationsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.medicationId,
      referencedTable: $db.medications,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MedicationsTableOrderingComposer(
            $db: $db,
            $table: $db.medications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DosesTableOrderingComposer get doseId {
    final $$DosesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.doseId,
      referencedTable: $db.doses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DosesTableOrderingComposer(
            $db: $db,
            $table: $db.doses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SchedulesTableAnnotationComposer
    extends Composer<_$AppDatabase, $SchedulesTable> {
  $$SchedulesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get medicationName => $composableBuilder(
    column: $table.medicationName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get frequency =>
      $composableBuilder(column: $table.frequency, builder: (column) => column);

  GeneratedColumnWithTypeConverter<List<String>, String> get days =>
      $composableBuilder(column: $table.days, builder: (column) => column);

  GeneratedColumn<DateTime> get time =>
      $composableBuilder(column: $table.time, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<bool> get notificationsEnabled => $composableBuilder(
    column: $table.notificationsEnabled,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notificationId => $composableBuilder(
    column: $table.notificationId,
    builder: (column) => column,
  );

  $$MedicationsTableAnnotationComposer get medicationId {
    final $$MedicationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.medicationId,
      referencedTable: $db.medications,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MedicationsTableAnnotationComposer(
            $db: $db,
            $table: $db.medications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DosesTableAnnotationComposer get doseId {
    final $$DosesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.doseId,
      referencedTable: $db.doses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DosesTableAnnotationComposer(
            $db: $db,
            $table: $db.doses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SchedulesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SchedulesTable,
          Schedule,
          $$SchedulesTableFilterComposer,
          $$SchedulesTableOrderingComposer,
          $$SchedulesTableAnnotationComposer,
          $$SchedulesTableCreateCompanionBuilder,
          $$SchedulesTableUpdateCompanionBuilder,
          (Schedule, $$SchedulesTableReferences),
          Schedule,
          PrefetchHooks Function({bool medicationId, bool doseId})
        > {
  $$SchedulesTableTableManager(_$AppDatabase db, $SchedulesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SchedulesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SchedulesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SchedulesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> medicationId = const Value.absent(),
                Value<String> medicationName = const Value.absent(),
                Value<int?> doseId = const Value.absent(),
                Value<String> frequency = const Value.absent(),
                Value<List<String>> days = const Value.absent(),
                Value<DateTime> time = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<bool> notificationsEnabled = const Value.absent(),
                Value<String?> notificationId = const Value.absent(),
              }) => SchedulesCompanion(
                id: id,
                medicationId: medicationId,
                medicationName: medicationName,
                doseId: doseId,
                frequency: frequency,
                days: days,
                time: time,
                name: name,
                notificationsEnabled: notificationsEnabled,
                notificationId: notificationId,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int medicationId,
                required String medicationName,
                Value<int?> doseId = const Value.absent(),
                required String frequency,
                required List<String> days,
                required DateTime time,
                Value<String> name = const Value.absent(),
                Value<bool> notificationsEnabled = const Value.absent(),
                Value<String?> notificationId = const Value.absent(),
              }) => SchedulesCompanion.insert(
                id: id,
                medicationId: medicationId,
                medicationName: medicationName,
                doseId: doseId,
                frequency: frequency,
                days: days,
                time: time,
                name: name,
                notificationsEnabled: notificationsEnabled,
                notificationId: notificationId,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SchedulesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({medicationId = false, doseId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (medicationId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.medicationId,
                                referencedTable: $$SchedulesTableReferences
                                    ._medicationIdTable(db),
                                referencedColumn: $$SchedulesTableReferences
                                    ._medicationIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (doseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.doseId,
                                referencedTable: $$SchedulesTableReferences
                                    ._doseIdTable(db),
                                referencedColumn: $$SchedulesTableReferences
                                    ._doseIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SchedulesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SchedulesTable,
      Schedule,
      $$SchedulesTableFilterComposer,
      $$SchedulesTableOrderingComposer,
      $$SchedulesTableAnnotationComposer,
      $$SchedulesTableCreateCompanionBuilder,
      $$SchedulesTableUpdateCompanionBuilder,
      (Schedule, $$SchedulesTableReferences),
      Schedule,
      PrefetchHooks Function({bool medicationId, bool doseId})
    >;
typedef $$DoseHistoryTableCreateCompanionBuilder =
    DoseHistoryCompanion Function({
      Value<int> id,
      required int doseId,
      required DateTime takenAt,
    });
typedef $$DoseHistoryTableUpdateCompanionBuilder =
    DoseHistoryCompanion Function({
      Value<int> id,
      Value<int> doseId,
      Value<DateTime> takenAt,
    });

final class $$DoseHistoryTableReferences
    extends BaseReferences<_$AppDatabase, $DoseHistoryTable, DoseHistoryData> {
  $$DoseHistoryTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $DosesTable _doseIdTable(_$AppDatabase db) => db.doses.createAlias(
    $_aliasNameGenerator(db.doseHistory.doseId, db.doses.id),
  );

  $$DosesTableProcessedTableManager get doseId {
    final $_column = $_itemColumn<int>('dose_id')!;

    final manager = $$DosesTableTableManager(
      $_db,
      $_db.doses,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_doseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$DoseHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $DoseHistoryTable> {
  $$DoseHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get takenAt => $composableBuilder(
    column: $table.takenAt,
    builder: (column) => ColumnFilters(column),
  );

  $$DosesTableFilterComposer get doseId {
    final $$DosesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.doseId,
      referencedTable: $db.doses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DosesTableFilterComposer(
            $db: $db,
            $table: $db.doses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DoseHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $DoseHistoryTable> {
  $$DoseHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get takenAt => $composableBuilder(
    column: $table.takenAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$DosesTableOrderingComposer get doseId {
    final $$DosesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.doseId,
      referencedTable: $db.doses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DosesTableOrderingComposer(
            $db: $db,
            $table: $db.doses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DoseHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $DoseHistoryTable> {
  $$DoseHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get takenAt =>
      $composableBuilder(column: $table.takenAt, builder: (column) => column);

  $$DosesTableAnnotationComposer get doseId {
    final $$DosesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.doseId,
      referencedTable: $db.doses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DosesTableAnnotationComposer(
            $db: $db,
            $table: $db.doses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DoseHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DoseHistoryTable,
          DoseHistoryData,
          $$DoseHistoryTableFilterComposer,
          $$DoseHistoryTableOrderingComposer,
          $$DoseHistoryTableAnnotationComposer,
          $$DoseHistoryTableCreateCompanionBuilder,
          $$DoseHistoryTableUpdateCompanionBuilder,
          (DoseHistoryData, $$DoseHistoryTableReferences),
          DoseHistoryData,
          PrefetchHooks Function({bool doseId})
        > {
  $$DoseHistoryTableTableManager(_$AppDatabase db, $DoseHistoryTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DoseHistoryTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DoseHistoryTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DoseHistoryTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> doseId = const Value.absent(),
                Value<DateTime> takenAt = const Value.absent(),
              }) => DoseHistoryCompanion(
                id: id,
                doseId: doseId,
                takenAt: takenAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int doseId,
                required DateTime takenAt,
              }) => DoseHistoryCompanion.insert(
                id: id,
                doseId: doseId,
                takenAt: takenAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$DoseHistoryTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({doseId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (doseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.doseId,
                                referencedTable: $$DoseHistoryTableReferences
                                    ._doseIdTable(db),
                                referencedColumn: $$DoseHistoryTableReferences
                                    ._doseIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$DoseHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DoseHistoryTable,
      DoseHistoryData,
      $$DoseHistoryTableFilterComposer,
      $$DoseHistoryTableOrderingComposer,
      $$DoseHistoryTableAnnotationComposer,
      $$DoseHistoryTableCreateCompanionBuilder,
      $$DoseHistoryTableUpdateCompanionBuilder,
      (DoseHistoryData, $$DoseHistoryTableReferences),
      DoseHistoryData,
      PrefetchHooks Function({bool doseId})
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$MedicationsTableTableManager get medications =>
      $$MedicationsTableTableManager(_db, _db.medications);
  $$DosesTableTableManager get doses =>
      $$DosesTableTableManager(_db, _db.doses);
  $$SchedulesTableTableManager get schedules =>
      $$SchedulesTableTableManager(_db, _db.schedules);
  $$DoseHistoryTableTableManager get doseHistory =>
      $$DoseHistoryTableTableManager(_db, _db.doseHistory);
}


// --- FILE BREAK ---

// File: lib/features/dose/constants/dose_form_constants.dart
import 'package:flutter/material.dart';

class DoseFormConstants {
  // Strings
  static const String unnamedDose = 'Unnamed Dose';
  static const String noDoseSpecified = 'No dose specified';
  static const String noDosesMessage = 'No doses scheduled';
  static const String defaultTabletUnit = 'mg';
  static const String tabletUnit = 'Tablet';
  static const String tabletCountLabel = 'Number of Tablets';
  static const String concentrationLabel = 'Concentration';
  static const String doseNameLabel = 'Dose Name';
  static const String notSet = 'Not set';
  static const String editTabletCountTitle = 'Edit Tablet Count';
  static const String editConcentrationTitle = 'Edit Concentration';
  static const String editDoseNameTitle = 'Edit Dose Name';
  static const String tabletCountHelper = 'Enter the number of tablets (e.g., 2)';
  static const String concentrationHelperTablet = 'Enter the total active compound (e.g., 200 mg)';
  static const String concentrationHelperNonTablet = 'Enter the dose amount (e.g., 1 mL)';
  static const String doseNameHelper = 'Enter a name for the dose (e.g., Ibuprofen Tablet)';
  static const String doseNameRequired = 'Name is required';
  static const String invalidRangeMessage = 'Dose value out of valid range (0.01â€“999)';
  static const String duplicateDoseMessage = 'A dose with this amount and unit already exists';
  static const String doseSavedMessage = 'Dose saved';
  static const String saveDoseButton = 'Save Dose';
  static const String updateDoseButton = 'Update Dose';
  static const String deleteDialogTitle = 'Confirm Deletion';
  static const String deleteDialogContent = 'Are you sure you want to delete this dose?';
  static const String cancelButton = 'Cancel';
  static const String deleteButton = 'Delete';

  static String screenTitle(String medicationName) => 'Doses for $medicationName';

  static String exceedStockMessage(double stock) => 'Dose exceeds available stock ($stock tablets)';

  static String errorSavingDose(Object error) => 'Error saving dose: $error';

  static String errorLoadingDoses(Object error) => 'Error: $error';

  // Paddings and Spacings
  static const EdgeInsets formPadding = EdgeInsets.all(16.0);
  static const EdgeInsets cardContentPadding = EdgeInsets.symmetric(horizontal: 16, vertical: 8);
  static const double sectionSpacing = 24.0;
  static const double fieldSpacing = 16.0;

  // Card Styling
  static const double cardElevation = 2.0;
  static const RoundedRectangleBorder cardShape = RoundedRectangleBorder(
    borderRadius: BorderRadius.all(Radius.circular(12)),
  );

  // Text Styles
  static TextStyle nameStyle(BuildContext context) => Theme.of(
    context,
  ).textTheme.bodyLarge!.copyWith(fontWeight: FontWeight.bold, color: Theme.of(context).colorScheme.primary);

  static TextStyle summaryStyle(BuildContext context) =>
      Theme.of(context).textTheme.bodyMedium!.copyWith(color: Colors.black54, fontSize: 14);

  static TextStyle buttonTextStyle(BuildContext context) =>
      Theme.of(context).textTheme.bodyLarge!.copyWith(color: Colors.white);

  // Button Style
  static final ButtonStyle buttonStyle = ElevatedButton.styleFrom(
    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
    shape: const RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(12))),
  );

  // AppBar Gradient
  static BoxDecoration appBarGradient(BuildContext context) => BoxDecoration(
    gradient: LinearGradient(
      colors: [Theme.of(context).colorScheme.primary, Theme.of(context).colorScheme.primary.withOpacity(0.8)],
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
    ),
  );
}

// --- FILE BREAK ---

// File: lib/features/dose/screens/dose_add_screen.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../common/medication_matrix.dart';
import '../../../common/utils/formatters.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../../medication/constants/medication_form_constants.dart';

class DosesAddScreen extends ConsumerStatefulWidget {
  final int? medicationId;
  const DosesAddScreen({super.key, this.medicationId});

  @override
  ConsumerState<DosesAddScreen> createState() => _DosesAddScreenState();
}

class _DosesAddScreenState extends ConsumerState<DosesAddScreen> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController(text: '0');
  int? _selectedMedicationId;
  String? _selectedMedicationName;
  TimeOfDay _selectedTime = TimeOfDay.now();
  int _currentStep = 0;
  List<Medication> _medications = [];

  @override
  void initState() {
    super.initState();
    if (widget.medicationId != null) {
      _selectedMedicationId = widget.medicationId;
      _loadMedications().then((_) {
        final med = _medications.firstWhere((m) => m.id == widget.medicationId);
        setState(() {
          _selectedMedicationName = med.name;
          _updateSummary();
        });
      });
    } else {
      _loadMedications();
    }
    _amountController.addListener(_updateSummary);
  }

  @override
  void dispose() {
    _amountController.dispose();
    super.dispose();
  }

  Future<void> _loadMedications() async {
    final meds = await ref.read(driftServiceProvider).getMedications();
    setState(() {
      _medications = meds;
    });
  }

  String get _summary {
    if (_selectedMedicationName == null || _amountController.text.isEmpty) return '';
    final amount = double.tryParse(_amountController.text) ?? 0;
    return 'Dose: $amount for $_selectedMedicationName at ${_selectedTime.format(context)}';
  }

  void _updateSummary() {
    setState(() {});
  }

  void _incrementAmount() {
    final current = double.tryParse(_amountController.text) ?? 0;
    _amountController.text = (current + 1).toInt().toString();
  }

  void _decrementAmount() {
    final current = double.tryParse(_amountController.text) ?? 0;
    if (current > 0) {
      _amountController.text = (current - 1).toInt().toString();
    }
  }

  void _saveDose() async {
    if (!_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text) ?? 0;
    if (_selectedMedicationId == null || amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a valid amount')),
      );
      return;
    }

    final medication = _medications.firstWhere((med) => med.id == _selectedMedicationId);
    final type = MedicationMatrix.formToType(medication.form);
    if (!MedicationMatrix.isValidValue(type, amount, 'quantity')) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Amount out of valid range (0.01â€“999)')),
      );
      return;
    }

    final dose = DosesCompanion(
      medicationId: drift.Value(_selectedMedicationId!),
      medicationName: drift.Value(_selectedMedicationName!),
      amount: drift.Value(amount),
      unit: drift.Value(medication.form == 'Tablet' || medication.form == 'Capsule' ? 'Tablet' : 'mL'),
      time: drift.Value(DateTime.now().copyWith(hour: _selectedTime.hour, minute: _selectedTime.minute)),
    );

    try {
      await ref.read(driftServiceProvider).addDose(dose);
      ref.invalidate(allDosesProvider);
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Dose added')),
      );
    } catch (e, stack) {
      debugPrint('Save error: $e\n$stack');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error adding dose: $e')),
      );
    }
  }

  List<Step> _buildSteps() {
    return [
      Step(
        title: const Text('Select Medication'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: _medications.map((med) {
                return ChoiceChip(
                  label: Text(med.name),
                  selected: _selectedMedicationId == med.id,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedMedicationId = med.id;
                        _selectedMedicationName = med.name;
                        _updateSummary();
                      });
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
        isActive: _currentStep == 0,
        state: _currentStep > 0 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Dose Amount'),
        content: Row(
          children: [
            Expanded(
              child: TextFormField(
                controller: _amountController,
                decoration: MedicationFormConstants.textFieldDecoration('Amount'),
                keyboardType: TextInputType.number,
                validator: (value) =>
                value!.isEmpty || double.tryParse(value) == null ? 'Valid number required' : null,
              ),
            ),
            Column(
              children: [
                IconButton(
                  icon: const Icon(Icons.arrow_upward),
                  onPressed: _incrementAmount,
                ),
                IconButton(
                  icon: const Icon(Icons.arrow_downward),
                  onPressed: _decrementAmount,
                ),
              ],
            ),
          ],
        ),
        isActive: _currentStep == 1,
        state: _currentStep > 1 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Dose Time'),
        content: ElevatedButton(
          onPressed: () async {
            final time = await showTimePicker(
              context: context,
              initialTime: _selectedTime,
            );
            if (time != null) {
              setState(() {
                _selectedTime = time;
                _updateSummary();
              });
            }
          },
          child: Text('Select Time: ${_selectedTime.format(context)}'),
        ),
        isActive: _currentStep == 2,
        state: _currentStep > 2 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Confirm'),
        content: Text(_summary.isEmpty ? 'Please complete all steps' : _summary),
        isActive: _currentStep == 3,
        state: _currentStep > 3 ? StepState.complete : StepState.indexed,
      ),
    ];
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Add Dose'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (_summary.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: Text(
                        _summary,
                        style: MedicationFormConstants.summaryStyle(context).copyWith(fontSize: 12),
                      ),
                    ),
                  const SizedBox(height: MedicationFormConstants.sectionSpacing),
                  Stepper(
                    currentStep: _currentStep,
                    onStepContinue: () {
                      if (_currentStep == 0 && _selectedMedicationId == null) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please select a medication')),
                        );
                        return;
                      }
                      if (_currentStep == 1 && _amountController.text.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please enter an amount')),
                        );
                        return;
                      }
                      if (_currentStep < _buildSteps().length - 1) {
                        setState(() => _currentStep += 1);
                      } else {
                        _saveDose();
                      }
                    },
                    onStepCancel: () {
                      if (_currentStep > 0) {
                        setState(() => _currentStep -= 1);
                      }
                    },
                    steps: _buildSteps(),
                    controlsBuilder: (context, details) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 16.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            if (details.onStepCancel != null)
                              TextButton(
                                onPressed: details.onStepCancel,
                                child: const Text('Back'),
                              ),
                            const SizedBox(width: 8),
                            ElevatedButton(
                              onPressed: details.onStepContinue,
                              style: MedicationFormConstants.buttonStyle,
                              child: Text(_currentStep == _buildSteps().length - 1 ? 'Save' : 'Next'),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/dose/screens/dose_edit_screen.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../common/medication_matrix.dart';
import '../../../common/utils/formatters.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../../medication/constants/medication_form_constants.dart';

class DosesEditScreen extends ConsumerStatefulWidget {
  final int doseId;
  const DosesEditScreen({super.key, required this.doseId});

  @override
  ConsumerState<DosesEditScreen> createState() => _DosesEditScreenState();
}

class _DosesEditScreenState extends ConsumerState<DosesEditScreen> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController(text: '0');
  int? _selectedMedicationId;
  String? _selectedMedicationName;
  TimeOfDay _selectedTime = TimeOfDay.now();
  int _currentStep = 0;
  List<Medication> _medications = [];
  Dose? _dose;

  @override
  void initState() {
    super.initState();
    _loadMedications();
    _loadDose();
    _amountController.addListener(_updateSummary);
  }

  @override
  void dispose() {
    _amountController.dispose();
    super.dispose();
  }

  Future<void> _loadMedications() async {
    final meds = await ref.read(driftServiceProvider).getMedications();
    setState(() {
      _medications = meds;
    });
  }

  Future<void> _loadDose() async {
    final dose = await ref.read(driftServiceProvider).getDoseById(widget.doseId);
    if (dose != null) {
      setState(() {
        _dose = dose;
        _selectedMedicationId = dose.medicationId;
        _selectedMedicationName = dose.medicationName;
        _amountController.text = Utils.removeTrailingZeros(dose.amount);
        _selectedTime = TimeOfDay.fromDateTime(dose.time);
        _updateSummary();
      });
    }
  }

  String get _summary {
    if (_selectedMedicationName == null || _amountController.text.isEmpty) return '';
    final amount = double.tryParse(_amountController.text) ?? 0;
    return 'Dose: $amount for $_selectedMedicationName at ${_selectedTime.format(context)}';
  }

  void _updateSummary() {
    setState(() {});
  }

  void _incrementAmount() {
    final current = double.tryParse(_amountController.text) ?? 0;
    _amountController.text = (current + 1).toInt().toString();
  }

  void _decrementAmount() {
    final current = double.tryParse(_amountController.text) ?? 0;
    if (current > 0) {
      _amountController.text = (current - 1).toInt().toString();
    }
  }

  void _saveDose() async {
    if (!_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text) ?? 0;
    if (_selectedMedicationId == null || amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a medication and enter a valid amount')),
      );
      return;
    }

    final medication = _medications.firstWhere((med) => med.id == _selectedMedicationId);
    final type = MedicationMatrix.formToType(medication.form);
    if (!MedicationMatrix.isValidValue(type, amount, 'quantity')) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Amount out of valid range (0.01â€“999)')),
      );
      return;
    }

    final dose = DosesCompanion(
      id: drift.Value(widget.doseId),
      medicationId: drift.Value(_selectedMedicationId!),
      medicationName: drift.Value(_selectedMedicationName!),
      amount: drift.Value(amount),
      unit: drift.Value(medication.form == 'Tablet' || medication.form == 'Capsule' ? 'Tablet' : 'mL'),
      time: drift.Value(DateTime.now().copyWith(hour: _selectedTime.hour, minute: _selectedTime.minute)),
    );

    try {
      await ref.read(driftServiceProvider).updateDose(widget.doseId, dose);
      ref.invalidate(allDosesProvider);
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Dose updated')),
      );
    } catch (e, stack) {
      debugPrint('Update error: $e\n$stack');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error updating dose: $e')),
      );
    }
  }

  List<Step> _buildSteps() {
    return [
      Step(
        title: const Text('Select Medication'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: _medications.map((med) {
                return ChoiceChip(
                  label: Text(med.name),
                  selected: _selectedMedicationId == med.id,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedMedicationId = med.id;
                        _selectedMedicationName = med.name;
                        _updateSummary();
                      });
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
        isActive: _currentStep == 0,
        state: _currentStep > 0 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Dose Amount'),
        content: Row(
          children: [
            Expanded(
              child: TextFormField(
                controller: _amountController,
                decoration: MedicationFormConstants.textFieldDecoration('Amount'),
                keyboardType: TextInputType.number,
                validator: (value) =>
                value!.isEmpty || double.tryParse(value) == null ? 'Valid number required' : null,
              ),
            ),
            Column(
              children: [
                IconButton(
                  icon: const Icon(Icons.arrow_upward),
                  onPressed: _incrementAmount,
                ),
                IconButton(
                  icon: const Icon(Icons.arrow_downward),
                  onPressed: _decrementAmount,
                ),
              ],
            ),
          ],
        ),
        isActive: _currentStep == 1,
        state: _currentStep > 1 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Dose Time'),
        content: ElevatedButton(
          onPressed: () async {
            final time = await showTimePicker(
              context: context,
              initialTime: _selectedTime,
            );
            if (time != null) {
              setState(() {
                _selectedTime = time;
                _updateSummary();
              });
            }
          },
          child: Text('Select Time: ${_selectedTime.format(context)}'),
        ),
        isActive: _currentStep == 2,
        state: _currentStep > 2 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Confirm'),
        content: Text(_summary.isEmpty ? 'Please complete all steps' : _summary),
        isActive: _currentStep == 3,
        state: _currentStep > 3 ? StepState.complete : StepState.indexed,
      ),
    ];
  }

  @override
  Widget build(BuildContext context) {
    if (_dose == null) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }
    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Dose'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (_summary.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: Text(
                        _summary,
                        style: MedicationFormConstants.summaryStyle(context).copyWith(fontSize: 12),
                      ),
                    ),
                  const SizedBox(height: MedicationFormConstants.sectionSpacing),
                  Stepper(
                    currentStep: _currentStep,
                    onStepContinue: () {
                      if (_currentStep == 0 && _selectedMedicationId == null) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please select a medication')),
                        );
                        return;
                      }
                      if (_currentStep == 1 && _amountController.text.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please enter an amount')),
                        );
                        return;
                      }
                      if (_currentStep < _buildSteps().length - 1) {
                        setState(() => _currentStep += 1);
                      } else {
                        _saveDose();
                      }
                    },
                    onStepCancel: () {
                      if (_currentStep > 0) {
                        setState(() => _currentStep -= 1);
                      }
                    },
                    steps: _buildSteps(),
                    controlsBuilder: (context, details) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 16.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            if (details.onStepCancel != null)
                              TextButton(
                                onPressed: details.onStepCancel,
                                child: const Text('Back'),
                              ),
                            const SizedBox(width: 8),
                            ElevatedButton(
                              onPressed: details.onStepContinue,
                              style: MedicationFormConstants.buttonStyle,
                              child: Text(_currentStep == _buildSteps().length - 1 ? 'Save' : 'Next'),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/dose/screens/dose_info_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../common/utils/formatters.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';

class DosesInfoScreen extends ConsumerWidget {
  const DosesInfoScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final dosesAsync = ref.watch(allDosesProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Doses'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: dosesAsync.when(
        data: (doses) => doses.isEmpty
            ? const Center(child: Text('No doses scheduled'))
            : ListView.builder(
          itemCount: doses.length,
          itemBuilder: (context, index) => Card(
            margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 16),
            child: ListTile(
              title: Text(doses[index].name ?? 'Unnamed'),
              subtitle: Text('Amount: ${Utils.removeTrailingZeros(doses[index].amount)} ${doses[index].unit}, Medication ID: ${doses[index].medicationId}'),
              trailing: IconButton(
                icon: const Icon(Icons.edit),
                onPressed: () => Navigator.pushNamed(context, '/doses/edit', arguments: doses[index].id),
              ),
            ),
          ),
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Card(
          margin: const EdgeInsets.all(16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Text('Error: $e', style: TextStyle(color: Theme.of(context).colorScheme.error)),
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.pushNamed(context, '/doses/add'),
        child: const Icon(Icons.add),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/history/screens/history_screen.dart
// lib/features/history/screens/history_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../../common/utils/formatters.dart'; // Add import
import '../../../data/database.dart';
import '../../../services/drift_service.dart';

class HistoryScreen extends ConsumerWidget {
  const HistoryScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final dosesAsync = ref.watch(allDosesProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('Dose History')),
      body: dosesAsync.when(
        data: (doses) => doses.isEmpty
            ? const Center(child: Text('No dose history'))
            : ListView.builder(
          itemCount: doses.length,
          itemBuilder: (context, index) {
            final dose = doses[index];
            return FutureBuilder<List<Medication>>(
              future: ref.read(driftServiceProvider).getMedications(),
              builder: (context, medSnapshot) {
                final medication = medSnapshot.data?.firstWhere(
                      (m) => m.id == dose.medicationId,
                  orElse: () => Medication(
                    id: dose.medicationId,
                    name: 'Medication',
                    concentration: 0,
                    concentrationUnit: '',
                    stockQuantity: 0,
                    form: '',
                  ),
                );
                return FutureBuilder<List<Schedule>>(
                  future: ref.read(driftServiceProvider).getSchedules(dose.medicationId),
                  builder: (context, scheduleSnapshot) {
                    final schedules = scheduleSnapshot.data?.where((s) => s.doseId == dose.id).toList() ?? [];
                    final scheduleText = schedules.isEmpty
                        ? 'No schedules'
                        : schedules
                        .map((s) => '${s.name} - ${DateFormat.jm().format(s.time)} (${s.days.join(', ')})')
                        .join('; ');
                    return ListTile(
                      title: Text(
                        '${Utils.removeTrailingZeros(dose.amount)} ${dose.unit} (${medication?.name ?? ''})',
                        style: Theme.of(context).textTheme.bodyLarge,
                      ),
                      subtitle: Text(
                        'Medication ID: ${dose.medicationId}\n'
                            'Weight: ${dose.weight != 0.0 ? Utils.removeTrailingZeros(dose.weight) : 'N/A'} kg\n'
                            'Schedules: $scheduleText',
                        style: Theme.of(context).textTheme.bodyLarge,
                      ),
                      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                      visualDensity: VisualDensity.compact,
                    );
                  },
                );
              },
            );
          },
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('Error: $e')),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/home/widgets/medication_card.dart
// lib/features/home/widgets/medication_card.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../../common/utils/formatters.dart'; // Add import
import '../../../data/database.dart';
import '../../../services/drift_service.dart';

class MedicationCard extends ConsumerWidget {
  final Medication medication;
  final VoidCallback onTap;
  final VoidCallback? onDoseTap;

  const MedicationCard({
    super.key,
    required this.medication,
    required this.onTap,
    this.onDoseTap,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final stockText =
        '${Utils.removeTrailingZeros(medication.stockQuantity)} x ${Utils.removeTrailingZeros(medication.concentration)}${medication.concentrationUnit} ${medication.form}';

    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
      child: ListTile(
        title: Text(
          medication.name,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
            color: Theme.of(context).colorScheme.primary,
          ),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              stockText,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            FutureBuilder<List<Schedule>>(
              future: ref.read(driftServiceProvider).getSchedules(medication.id),
              builder: (context, scheduleSnapshot) {
                print('Schedule snapshot for medication ${medication.id}: ${scheduleSnapshot.data}, state: ${scheduleSnapshot.connectionState}');
                if (scheduleSnapshot.connectionState == ConnectionState.waiting || !scheduleSnapshot.hasData) {
                  return const SizedBox.shrink();
                }
                final allSchedules = scheduleSnapshot.data!;
                if (allSchedules.isEmpty) return const SizedBox.shrink();
                final scheduleText = allSchedules
                    .map((s) => s.frequency == 'Daily'
                    ? '${s.name} - Daily at ${DateFormat.jm().format(s.time)}'
                    : '${s.name} - ${s.days.join(', ')} at ${DateFormat.jm().format(s.time)}')
                    .join('; ');
                return Text(
                  'Schedules: $scheduleText',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(color: Colors.black54),
                );
              },
            ),
          ],
        ),
        onTap: onTap,
        contentPadding: const EdgeInsets.all(16),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/home/home_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:intl/intl.dart';
import '../../common/utils/formatters.dart';
import '../../data/database.dart';
import '../../services/drift_service.dart';
import '../../services/dose_service.dart';

class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});

  @override
  void _showDoseDialog(BuildContext context, WidgetRef ref, Schedule schedule) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Dose: ${schedule.medicationName}'),
        content: Text('Time: ${DateFormat.jm().format(schedule.time)}'),
        actions: [
          TextButton(
            onPressed: () async {
              await ref.read(doseServiceProvider).takeDose(
                schedule.medicationId,
                schedule.doseId!,
                1.0,
              );
              ref.invalidate(schedulesProvider);
              Navigator.pop(context);
            },
            child: const Text('Take', style: TextStyle(color: Colors.green)),
          ),
          TextButton(
            onPressed: () async {
              await ref.read(doseServiceProvider).snoozeDose(schedule.id);
              ref.invalidate(schedulesProvider);
              Navigator.pop(context);
            },
            child: const Text('Snooze', style: TextStyle(color: Colors.orange)),
          ),
          TextButton(
            onPressed: () async {
              await ref.read(doseServiceProvider).cancelDose(schedule.id);
              ref.invalidate(schedulesProvider);
              Navigator.pop(context);
            },
            child: const Text('Cancel', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }
  Widget build(BuildContext context, WidgetRef ref) {
    final medicationsAsync = ref.watch(medicationsProvider);
    final dosesAsync = ref.watch(allDosesProvider);
    final schedulesAsync = ref.watch(schedulesProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('MedMinder Dashboard'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Upcoming Doses', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            schedulesAsync.when(
              data: (schedules) => schedules.isEmpty
                  ? const Padding(
                padding: EdgeInsets.symmetric(vertical: 8),
                child: Text('No schedules'),
              )
                  : FutureBuilder<List<Schedule>>(
                future: Future.wait(schedules.map((s) async {
                  final isAvailable = await ref.read(doseServiceProvider).isDoseAvailableToday(s);
                  return isAvailable ? s : null;
                })).then((list) => list.whereType<Schedule>().toList()),
                builder: (context, snapshot) {
                  if (!snapshot.hasData) return const CircularProgressIndicator();
                  final upcoming = snapshot.data!;
                  if (upcoming.isEmpty) return const Text('No upcoming doses today');
                  return Column(
                    children: upcoming.map((schedule) {
                      return Card(
                        margin: const EdgeInsets.symmetric(vertical: 4),
                        child: ListTile(
                          title: Text(schedule.medicationName),
                          subtitle: Text(
                            'Time: ${DateFormat.jm().format(schedule.time)}, Days: ${schedule.days.join(', ')}',
                          ),
                          onTap: schedule.doseId != null
                              ? () => _showDoseDialog(context, ref, schedule)
                              : null,
                        ),
                      );
                    }).toList(),
                  );
                },
              ),
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (e, _) => _buildErrorWidget(context, e.toString()),
            ),
            const SizedBox(height: 16),
            const Text('Medication Stock', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            medicationsAsync.when(
              data: (meds) => meds.isEmpty
                  ? const Padding(
                padding: EdgeInsets.symmetric(vertical: 8),
                child: Text('No medications'),
              )
                  : Column(
                children: meds.map((med) => Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: Text(med.name),
                    subtitle: Text(
                      'Stock: ${Utils.removeTrailingZeros(med.stockQuantity)} ${med.form == 'Tablet' || med.form == 'Capsule' ? med.form : med.concentrationUnit}',
                    ),
                    trailing: med.stockQuantity < 10
                        ? const Chip(label: Text('Low Stock'), backgroundColor: Colors.red)
                        : null,
                    onTap: () => Navigator.pushNamed(context, '/medications/edit', arguments: med.id),
                  ),
                )).toList(),
              ),
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (e, _) => _buildErrorWidget(context, e.toString()),
            ),
            const SizedBox(height: 16),
            const Text('Adherence', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            Card(
              margin: const EdgeInsets.symmetric(vertical: 4),
              child: Column(
                children: [
                  const ListTile(
                    title: Text('Weekly Adherence'),
                    subtitle: Text('Based on taken doses over the past 7 days'),
                  ),
                  SizedBox(
                    height: 200,
                    child: dosesAsync.when(
                      data: (doses) {
                        final takenDoses = doses.where((dose) => dose.taken).length;
                        final totalDoses = doses.length;
                        final adherence = totalDoses > 0 ? (takenDoses / totalDoses * 100).toInt() : 0;
                        return PieChart(
                          PieChartData(
                            sections: [
                              PieChartSectionData(
                                value: adherence.toDouble(),
                                color: Colors.green,
                                title: '$adherence%',
                                radius: 50,
                              ),
                              PieChartSectionData(
                                value: (100 - adherence).toDouble(),
                                color: Colors.red,
                                title: '${100 - adherence}%',
                                radius: 50,
                              ),
                            ],
                            centerSpaceRadius: 40,
                          ),
                        );
                      },
                      loading: () => const CircularProgressIndicator(),
                      error: (e, _) => Text('Error: $e'),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildErrorWidget(BuildContext context, String error) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8),
      color: Theme.of(context).colorScheme.error.withOpacity(0.1),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Text(
          'Error: $error',
          style: TextStyle(color: Theme.of(context).colorScheme.error),
        ),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/constants/medication_form_constants.dart
// lib/features/medication/constants/medication_form_constants.dart
import 'package:flutter/material.dart';

class MedicationFormConstants {
  // Strings
  static const String addMedicationTitle = 'Add Medication';
  static const String selectTypeTitle = 'Select Medication Type';
  static const String defaultUnit = 'mg';
  static const String defaultForm = 'Medication';
  static const String nameLabel = 'Medication Name';
  static const String concentrationLabel = 'Concentration';
  static const String quantityLabel = 'Quantity';
  static const String unitsLabel = 'units';
  static const String nameRequiredMessage = 'Medication Name is required';
  static const String concentrationRequiredMessage = 'Concentration is required';
  static const String quantityRequiredMessage = 'Quantity is required';
  static const String invalidNumberMessage = 'Enter a valid number';
  static const String typeRequiredMessage = 'Medication Type is required';
  static const String selectTypeMessage = 'Please select a medication type';
  static const String invalidRangeMessage = 'Values out of valid range (0.01â€“999)';
  static const String duplicateNameMessage = 'A medication with this name already exists';
  static const String medicationSavedMessage = 'Medication saved';
  static const String warningTitle = 'Warning';
  static const String warningContent = 'Editing this medication may impact existing doses or schedules. Do you want to proceed?';
  static const String cancelButton = 'Cancel';
  static const String proceedButton = 'Proceed';
  static const String continueButton = 'Continue';
  static const String saveButton = 'Save Medication';
  static const List<String> medicationTypes = ['Tablet', 'Capsule', 'Injection', 'Drops'];
  static const String powderAmountLabel = 'Powder Amount';
  static const String solventVolumeLabel = 'Solvent Volume';
  static const String volumeLabel = 'Volume';
  static const String dropsQuantityLabel = 'Total Drops';
  static const String reconstitutionRequiredMessage = 'Reconstitution fields required';
  static const String volumeRequiredMessage = 'Volume is required';


  static String errorSavingMessage(Object error) => 'Error: $error';

  // Paddings and Spacings
  static const EdgeInsets formPadding = EdgeInsets.zero;
  static const EdgeInsets cardPadding = EdgeInsets.all(8.0);
  static const double sectionSpacing = 16.0;
  static const double fieldSpacing = 16.0;
  static const double buttonSpacing = 32.0;

  // Card Styling
  static const double cardElevation = 2.0;
  static const RoundedRectangleBorder cardShape = RoundedRectangleBorder(
    borderRadius: BorderRadius.all(Radius.circular(12)),
  );

  // Styles
  static const TextStyle titleStyle = TextStyle(fontSize: 20, fontWeight: FontWeight.bold);

  static TextStyle summaryStyle(BuildContext context) => Theme.of(context).textTheme.bodyLarge!.copyWith(
    fontWeight: FontWeight.bold,
    color: Theme.of(context).colorScheme.primary,
  );

  // Decorations
  static InputDecoration textFieldDecoration(String label) => InputDecoration(
    labelText: label,
    border: const OutlineInputBorder(
      borderRadius: BorderRadius.all(Radius.circular(12)),
    ),
    filled: true,
    fillColor: Colors.grey[100],
  );

  static InputDecoration get dropdownDecoration => InputDecoration(
    labelText: 'Medication Type',
    helperText: 'Choose Medication Type',
    helperMaxLines: 2,
    border: const OutlineInputBorder(
      borderRadius: BorderRadius.all(Radius.circular(12)),
    ),
    filled: true,
    fillColor: Colors.grey[100],
    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 18),
  );

  // Button Style
  static final ButtonStyle buttonStyle = ElevatedButton.styleFrom(
    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
    shape: const RoundedRectangleBorder(
      borderRadius: BorderRadius.all(Radius.circular(12)),
    ),
  );
}

// --- FILE BREAK ---

// File: lib/features/medication/screens/medication_add_screen.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../common/constants/app_strings.dart';
import '../../../common/medication_matrix.dart';
import '../../../common/utils/formatters.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../constants/medication_form_constants.dart';
import '../widgets/type_specific_fields/tablet_fields.dart';
import '../widgets/type_specific_fields/injection_fields.dart';
import '../widgets/type_specific_fields/drops_fields.dart';

class MedicationsAddScreen extends ConsumerStatefulWidget {
  const MedicationsAddScreen({super.key});

  @override
  ConsumerState<MedicationsAddScreen> createState() => _MedicationsAddScreenState();
}

class _MedicationsAddScreenState extends ConsumerState<MedicationsAddScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _concentrationController = TextEditingController(text: '0');
  final _quantityController = TextEditingController(text: '0');
  final _volumeController = TextEditingController(text: '0');
  final _totalLiquidController = TextEditingController(text: '0');
  final _powderAmountController = TextEditingController(text: '0');
  final _solventVolumeController = TextEditingController(text: '0');
  String _unit = MedicationFormConstants.defaultUnit;
  MedicationType _selectedType = MedicationType.tablet;
  String? _selectedForm;
  String _summary = '';
  bool _requiresReconstitution = false;
  String _deliveryMethod = 'Pre-filled Syringe';
  int _currentStep = 0;
  List<String> _existingMedicationNames = [];

  @override
  void initState() {
    super.initState();
    _loadExistingMedications();
    _selectedForm = Units.forms.first;
    _unit = MedicationMatrix.getConcentrationUnits(_selectedType).first;
    _updateSummary();
    _setupListeners();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _concentrationController.dispose();
    _quantityController.dispose();
    _volumeController.dispose();
    _totalLiquidController.dispose();
    _powderAmountController.dispose();
    _solventVolumeController.dispose();
    super.dispose();
  }

  void _setupListeners() {
    _nameController.addListener(_updateSummary);
    _concentrationController.addListener(_updateSummary);
    _quantityController.addListener(_updateSummary);
    _volumeController.addListener(_updateSummary);
    _totalLiquidController.addListener(_updateSummary);
    _powderAmountController.addListener(_updateSummary);
    _solventVolumeController.addListener(_updateSummary);
  }

  Future<void> _loadExistingMedications() async {
    final medications = await ref.read(driftServiceProvider).getMedications();
    setState(() {
      _existingMedicationNames = medications.map((med) => med.name).toList();
    });
  }

  void _updateSummary() {
    if (_nameController.text.isEmpty || _selectedForm == null) {
      _summary = '';
      return;
    }
    final name = _nameController.text;
    final concentration = double.tryParse(_concentrationController.text) ?? 0;
    final quantity = double.tryParse(_quantityController.text) ?? 0;
    final volume = double.tryParse(_volumeController.text) ?? 0;
    final totalLiquid = double.tryParse(_totalLiquidController.text) ?? 0;
    String summary = '';
    if (_selectedType == MedicationType.tablet || _selectedType == MedicationType.capsule) {
      final total = concentration * quantity;
      final pluralForm = quantity == 1 ? _selectedForm! : '${_selectedForm}s';
      summary = '${Utils.removeTrailingZeros(quantity)} x ${Utils.removeTrailingZeros(concentration)}$_unit $pluralForm${total > 0 ? ' (${Utils.removeTrailingZeros(total)}$_unit total)' : ''}';
    } else if (_selectedType == MedicationType.injection) {
      summary = '${Utils.removeTrailingZeros(concentration)}$_unit $name ${_selectedForm}${_requiresReconstitution ? ' (Reconstituted)' : ''} (${totalLiquid > 0 ? Utils.removeTrailingZeros(totalLiquid) : 'N/A'} mL)';
    } else if (_selectedType == MedicationType.drops) {
      summary = '${Utils.removeTrailingZeros(volume)} mL $name ${_selectedForm}';
    } else if (_selectedType == MedicationType.inhaler || _selectedType == MedicationType.nasalSpray) {
      summary = '${Utils.removeTrailingZeros(quantity)} ${_selectedForm} $name (${Utils.removeTrailingZeros(concentration)}$_unit)';
    } else if (_selectedType == MedicationType.ointmentCream) {
      summary = '${Utils.removeTrailingZeros(quantity)} g $name ${_selectedForm} (${Utils.removeTrailingZeros(concentration)}$_unit)';
    } else if (_selectedType == MedicationType.patch || _selectedType == MedicationType.suppository) {
      summary = '${Utils.removeTrailingZeros(quantity)} ${_selectedForm} $name (${Utils.removeTrailingZeros(concentration)}$_unit)';
    }
    setState(() => _summary = summary);
  }

  Future<bool> _isNameUnique(String name) async {
    final medications = await ref.read(driftServiceProvider).getMedications();
    return !medications.any((med) => med.name.toLowerCase() == name.toLowerCase());
  }

  void _incrementField(TextEditingController controller, {bool isInteger = false}) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    final newValue = isInteger ? currentValue + 1 : currentValue + 0.01;
    controller.text = isInteger ? newValue.toInt().toString() : Utils.removeTrailingZeros(newValue);
  }

  void _decrementField(TextEditingController controller, {bool isInteger = false}) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    if (currentValue > 0) {
      final newValue = isInteger ? currentValue - 1 : currentValue - 0.01;
      controller.text = isInteger ? newValue.toInt().toString() : Utils.removeTrailingZeros(newValue);
    }
  }

  void _saveMedication() async {
    if (!_formKey.currentState!.validate()) return;

    final name = _nameController.text;
    final concentration = double.tryParse(_concentrationController.text) ?? 0;
    final quantity = double.tryParse(_quantityController.text) ?? 0;
    final volume = double.tryParse(_volumeController.text) ?? 0;
    final totalLiquid = double.tryParse(_totalLiquidController.text) ?? 0;
    final powderAmount = double.tryParse(_powderAmountController.text) ?? 0;

    try {
      if (_selectedType == MedicationType.injection) {
        if (_requiresReconstitution && powderAmount <= 0) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Powder amount required for reconstituted vials')),
          );
          return;
        }
        if (!_requiresReconstitution && _deliveryMethod == 'Vial' && totalLiquid <= 0) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Total volume required for non-reconstituted vials')),
          );
          return;
        }
      }

      if (_selectedType == MedicationType.drops && volume <= 0) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Total volume required for drops')),
        );
        return;
      }

      if (concentration <= 0 || (_selectedType == MedicationType.drops && volume <= 0) ||
          (_selectedType != MedicationType.injection && quantity <= 0)) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('All values must be greater than 0')),
        );
        return;
      }

      if (!MedicationMatrix.isValidValue(_selectedType, concentration, 'concentration')) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Concentration out of valid range (0.0001â€“999)')),
        );
        return;
      }

      if (_selectedType != MedicationType.injection && !MedicationMatrix.isValidValue(_selectedType, quantity, 'quantity') ||
          (_selectedType == MedicationType.drops && !MedicationMatrix.isValidValue(_selectedType, volume, 'quantity')) ||
          (_selectedType == MedicationType.injection && !_requiresReconstitution && _deliveryMethod == 'Vial' && !MedicationMatrix.isValidValue(_selectedType, totalLiquid, 'quantity'))) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Quantity or volume out of valid range (0.01â€“999)')),
        );
        return;
      }

      if (!(await _isNameUnique(name))) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text(MedicationFormConstants.duplicateNameMessage)),
        );
        return;
      }

      final medication = MedicationsCompanion(
        name: drift.Value(name),
        concentration: drift.Value(concentration),
        concentrationUnit: drift.Value(_unit),
        stockQuantity: drift.Value(_selectedType == MedicationType.drops ? volume : _selectedType == MedicationType.injection ? totalLiquid : quantity),
        form: drift.Value(_selectedForm!),
      );

      await ref.read(driftServiceProvider).addMedication(medication);
      ref.invalidate(medicationsProvider);
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text(MedicationFormConstants.medicationSavedMessage)),
      );
    } catch (e, stack) {
      debugPrint('Save error: $e\n$stack');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(MedicationFormConstants.errorSavingMessage(e))),
      );
    }
  }

  String get _quantityUnit {
    if (_selectedType == MedicationType.tablet) return (double.tryParse(_quantityController.text) ?? 0) == 1 ? 'Tablet' : 'Tablets';
    if (_selectedType == MedicationType.capsule) return (double.tryParse(_quantityController.text) ?? 0) == 1 ? 'Capsule' : 'Capsules';
    if (_selectedType == MedicationType.patch) return (double.tryParse(_quantityController.text) ?? 0) == 1 ? 'Patch' : 'Patches';
    if (_selectedType == MedicationType.suppository) return (double.tryParse(_quantityController.text) ?? 0) == 1 ? 'Suppository' : 'Suppositories';
    return '';
  }

  List<Step> _buildSteps() {
    return [
      Step(
        title: const Text('Select Medication Type'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: Units.forms.map((form) {
                final type = MedicationType.values.firstWhere(
                      (t) => t.toString().split('.').last == form.toLowerCase().replaceAll('/', '').replaceAll(' ', ''),
                  orElse: () => MedicationType.tablet,
                );
                return ChoiceChip(
                  label: Text(form),
                  avatar: Icon(_getIconForForm(form)),
                  selected: _selectedForm == form,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedForm = form;
                        _selectedType = type;
                        _unit = MedicationMatrix.getConcentrationUnits(_selectedType).first;
                        _requiresReconstitution = false;
                        _deliveryMethod = 'Pre-filled Syringe';
                        _updateSummary();
                      });
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
        isActive: _currentStep == 0,
        state: _currentStep > 0 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Medication Name'),
        content: Autocomplete<String>(
          optionsBuilder: (TextEditingValue textEditingValue) {
            if (textEditingValue.text.isEmpty) {
              return const Iterable<String>.empty();
            }
            return _existingMedicationNames.where((String option) =>
                option.toLowerCase().contains(textEditingValue.text.toLowerCase()));
          },
          onSelected: (String selection) {
            _nameController.text = selection;
            _updateSummary();
          },
          fieldViewBuilder: (context, controller, focusNode, onFieldSubmitted) {
            return TextFormField(
              controller: _nameController,
              focusNode: focusNode,
              decoration: MedicationFormConstants.textFieldDecoration('Medication Name'),
              validator: (value) => value!.isEmpty ? 'Name is required' : null,
              onChanged: (value) => _updateSummary(),
            );
          },
        ),
        isActive: _currentStep == 1,
        state: _currentStep > 1 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Concentration & Unit'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    controller: _concentrationController,
                    decoration: MedicationFormConstants.textFieldDecoration('Concentration'),
                    keyboardType: TextInputType.number,
                    validator: (value) =>
                    value!.isEmpty || double.tryParse(value) == null ? 'Valid number required' : null,
                  ),
                ),
                Column(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.arrow_upward),
                      onPressed: () => _incrementField(_concentrationController),
                    ),
                    IconButton(
                      icon: const Icon(Icons.arrow_downward),
                      onPressed: () => _decrementField(_concentrationController),
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 8,
              children: MedicationMatrix.getConcentrationUnits(_selectedType).map((unitType) {
                return ChoiceChip(
                  label: Text(unitType),
                  selected: _unit == unitType,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _unit = unitType;
                        _updateSummary();
                      });
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
        isActive: _currentStep == 2,
        state: _currentStep > 2 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Quantity/Volume'),
        content: _selectedType == MedicationType.tablet || _selectedType == MedicationType.capsule ||
            _selectedType == MedicationType.patch || _selectedType == MedicationType.suppository
            ? TabletFields(
          concentrationController: _concentrationController,
          quantityController: _quantityController,
          unitController: TextEditingController(text: _unit),
          selectedType: _selectedType,
          onUnitChanged: (value) => setState(() => _unit = value ?? _unit),
          maxWidth: MediaQuery.of(context).size.width * 0.9,
        )
            : _selectedType == MedicationType.injection
            ? InjectionFields(
          concentrationController: _concentrationController,
          unitController: TextEditingController(text: _unit),
          powderAmountController: _powderAmountController,
          solventVolumeController: _solventVolumeController,
          totalLiquidController: _totalLiquidController,
          requiresReconstitution: _requiresReconstitution,
          onReconstitutionChanged: (value) => setState(() => _requiresReconstitution = value),
          onUnitChanged: (value) => setState(() => _unit = value ?? _unit),
          maxWidth: MediaQuery.of(context).size.width * 0.9,
        )
            : _selectedType == MedicationType.drops
            ? DropsFields(
          concentrationController: _concentrationController,
          volumeController: _volumeController,
          unitController: TextEditingController(text: _unit),
          onUnitChanged: (value) => setState(() => _unit = value ?? _unit),
          maxWidth: MediaQuery.of(context).size.width * 0.9,
        )
            : Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    controller: _quantityController,
                    decoration: MedicationFormConstants.textFieldDecoration('Quantity'),
                    keyboardType: TextInputType.number,
                    validator: (value) =>
                    value!.isEmpty || double.tryParse(value) == null ? 'Valid number required' : null,
                  ),
                ),
                Column(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.arrow_upward),
                      onPressed: () => _incrementField(_quantityController, isInteger: true),
                    ),
                    IconButton(
                      icon: const Icon(Icons.arrow_downward),
                      onPressed: () => _decrementField(_quantityController, isInteger: true),
                    ),
                  ],
                ),
              ],
            ),
          ],
        ),
        isActive: _currentStep == 3,
        state: _currentStep > 3 ? StepState.complete : StepState.indexed,
      ),
    ];
  }

  IconData _getIconForForm(String form) {
    switch (form) {
      case 'Tablet':
        return Icons.tablet;
      case 'Capsule':
        return Icons.medication;
      case 'Injection':
        return Icons.medical_services;
      case 'Drops':
        return Icons.water_drop;
      case 'Inhaler':
        return Icons.air;
      case 'Ointment/Cream':
        return Icons.spa;
      case 'Patch':
        return Icons.healing;
      case 'Nasal Spray':
        return Icons.sanitizer;
      case 'Suppository':
        return Icons.medical_information;
      default:
        return Icons.medication;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(MedicationFormConstants.addMedicationTitle),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (_summary.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: Text(
                        _summary,
                        style: MedicationFormConstants.summaryStyle(context).copyWith(fontSize: 12),
                      ),
                    ),
                  const SizedBox(height: MedicationFormConstants.sectionSpacing),
                  Stepper(
                    currentStep: _currentStep,
                    onStepContinue: () {
                      if (_currentStep == 0 && _selectedForm == null) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please select a medication type')),
                        );
                        return;
                      }
                      if (_currentStep == 1 && _nameController.text.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please enter a medication name')),
                        );
                        return;
                      }
                      if (_currentStep < _buildSteps().length - 1) {
                        setState(() => _currentStep += 1);
                      } else {
                        _saveMedication();
                      }
                    },
                    onStepCancel: () {
                      if (_currentStep > 0) {
                        setState(() => _currentStep -= 1);
                      }
                    },
                    steps: _buildSteps(),
                    controlsBuilder: (context, details) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 16.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            if (details.onStepCancel != null)
                              TextButton(
                                onPressed: details.onStepCancel,
                                child: const Text('Back'),
                              ),
                            const SizedBox(width: 8),
                            ElevatedButton(
                              onPressed: details.onStepContinue,
                              style: MedicationFormConstants.buttonStyle,
                              child: Text(_currentStep == _buildSteps().length - 1 ? 'Save' : 'Next'),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/screens/medication_edit_screen.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../common/constants/app_strings.dart';
import '../../../common/medication_matrix.dart';
import '../../../common/utils/formatters.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../constants/medication_form_constants.dart';
import '../widgets/type_specific_fields/tablet_fields.dart';
import '../widgets/type_specific_fields/injection_fields.dart';
import '../widgets/type_specific_fields/drops_fields.dart';

class MedicationsEditScreen extends ConsumerStatefulWidget {
  final int medicationId;
  const MedicationsEditScreen({super.key, required this.medicationId});

  @override
  ConsumerState<MedicationsEditScreen> createState() => _MedicationsEditScreenState();
}

class _MedicationsEditScreenState extends ConsumerState<MedicationsEditScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _concentrationController = TextEditingController(text: '0');
  final _quantityController = TextEditingController(text: '0');
  final _volumeController = TextEditingController(text: '0');
  final _totalLiquidController = TextEditingController(text: '0');
  final _powderAmountController = TextEditingController(text: '0');
  final _solventVolumeController = TextEditingController(text: '0');
  String _unit = MedicationFormConstants.defaultUnit;
  MedicationType _selectedType = MedicationType.tablet;
  String? _selectedForm;
  String _summary = '';
  bool _requiresReconstitution = false;
  String _deliveryMethod = 'Pre-filled Syringe';
  int _currentStep = 0;
  List<String> _existingMedicationNames = [];
  Medication? _medication;

  @override
  void initState() {
    super.initState();
    _loadMedication();
    _loadExistingMedications();
    _setupListeners();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _concentrationController.dispose();
    _quantityController.dispose();
    _volumeController.dispose();
    _totalLiquidController.dispose();
    _powderAmountController.dispose();
    _solventVolumeController.dispose();
    super.dispose();
  }

  void _setupListeners() {
    _nameController.addListener(_updateSummary);
    _concentrationController.addListener(_updateSummary);
    _quantityController.addListener(_updateSummary);
    _volumeController.addListener(_updateSummary);
    _totalLiquidController.addListener(_updateSummary);
    _powderAmountController.addListener(_updateSummary);
    _solventVolumeController.addListener(_updateSummary);
  }

  Future<void> _loadMedication() async {
    final med = await ref.read(driftServiceProvider).getMedicationById(widget.medicationId);
    if (med != null) {
      setState(() {
        _medication = med;
        _nameController.text = med.name;
        _concentrationController.text = Utils.removeTrailingZeros(med.concentration);
        _quantityController.text = Utils.removeTrailingZeros(med.stockQuantity);
        _unit = med.concentrationUnit;
        _selectedForm = med.form;
        _selectedType = MedicationMatrix.formToType(med.form);
        _updateSummary();
      });
    }
  }

  Future<void> _loadExistingMedications() async {
    final medications = await ref.read(driftServiceProvider).getMedications();
    setState(() {
      _existingMedicationNames = medications.map((med) => med.name).toList();
    });
  }

  void _updateSummary() {
    if (_nameController.text.isEmpty || _selectedForm == null) {
      _summary = '';
      return;
    }
    final name = _nameController.text;
    final concentration = double.tryParse(_concentrationController.text) ?? 0;
    final quantity = double.tryParse(_quantityController.text) ?? 0;
    final volume = double.tryParse(_volumeController.text) ?? 0;
    final totalLiquid = double.tryParse(_totalLiquidController.text) ?? 0;
    String summary = '';
    if (_selectedType == MedicationType.tablet || _selectedType == MedicationType.capsule) {
      final total = concentration * quantity;
      final pluralForm = quantity == 1 ? _selectedForm! : '${_selectedForm}s';
      summary = '${Utils.removeTrailingZeros(quantity)} x ${Utils.removeTrailingZeros(concentration)}$_unit $pluralForm${total > 0 ? ' (${Utils.removeTrailingZeros(total)}$_unit total)' : ''}';
    } else if (_selectedType == MedicationType.injection) {
      summary = '${Utils.removeTrailingZeros(concentration)}$_unit $name ${_selectedForm}${_requiresReconstitution ? ' (Reconstituted)' : ''} (${totalLiquid > 0 ? Utils.removeTrailingZeros(totalLiquid) : 'N/A'} mL)';
    } else if (_selectedType == MedicationType.drops) {
      summary = '${Utils.removeTrailingZeros(volume)} mL $name ${_selectedForm}';
    } else if (_selectedType == MedicationType.inhaler || _selectedType == MedicationType.nasalSpray) {
      summary = '${Utils.removeTrailingZeros(quantity)} ${_selectedForm} $name (${Utils.removeTrailingZeros(concentration)}$_unit)';
    } else if (_selectedType == MedicationType.ointmentCream) {
      summary = '${Utils.removeTrailingZeros(quantity)} g $name ${_selectedForm} (${Utils.removeTrailingZeros(concentration)}$_unit)';
    } else if (_selectedType == MedicationType.patch || _selectedType == MedicationType.suppository) {
      summary = '${Utils.removeTrailingZeros(quantity)} ${_selectedForm} $name (${Utils.removeTrailingZeros(concentration)}$_unit)';
    }
    setState(() => _summary = summary);
  }

  Future<bool> _isNameUnique(String name) async {
    final medications = await ref.read(driftServiceProvider).getMedications();
    return !medications.any((med) => med.name.toLowerCase() == name.toLowerCase() && med.id != widget.medicationId);
  }

  void _incrementField(TextEditingController controller, {bool isInteger = false}) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    final newValue = isInteger ? currentValue + 1 : currentValue + 0.01;
    controller.text = isInteger ? newValue.toInt().toString() : Utils.removeTrailingZeros(newValue);
  }

  void _decrementField(TextEditingController controller, {bool isInteger = false}) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    if (currentValue > 0) {
      final newValue = isInteger ? currentValue - 1 : currentValue - 0.01;
      controller.text = isInteger ? newValue.toInt().toString() : Utils.removeTrailingZeros(newValue);
    }
  }

  void _saveMedication() async {
    if (!_formKey.currentState!.validate()) return;

    final name = _nameController.text;
    final concentration = double.tryParse(_concentrationController.text) ?? 0;
    final quantity = double.tryParse(_quantityController.text) ?? 0;
    final volume = double.tryParse(_volumeController.text) ?? 0;
    final totalLiquid = double.tryParse(_totalLiquidController.text) ?? 0;
    final powderAmount = double.tryParse(_powderAmountController.text) ?? 0;

    try {
      if (_selectedType == MedicationType.injection) {
        if (_requiresReconstitution && powderAmount <= 0) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Powder amount required for reconstituted vials')),
          );
          return;
        }
        if (!_requiresReconstitution && _deliveryMethod == 'Vial' && totalLiquid <= 0) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Total volume required for non-reconstituted vials')),
          );
          return;
        }
      }

      if (_selectedType == MedicationType.drops && volume <= 0) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Total volume required for drops')),
        );
        return;
      }

      if (concentration <= 0 ||
          (_selectedType == MedicationType.drops && volume <= 0) ||
          (_selectedType != MedicationType.injection && quantity <= 0)) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('All values must be greater than 0')),
        );
        return;
      }

      if (!MedicationMatrix.isValidValue(_selectedType, concentration, 'concentration')) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Concentration out of valid range (0.0001â€“999)')),
        );
        return;
      }

      if (_selectedType != MedicationType.injection &&
          !MedicationMatrix.isValidValue(_selectedType, quantity, 'quantity') ||
          (_selectedType == MedicationType.drops &&
              !MedicationMatrix.isValidValue(_selectedType, volume, 'quantity')) ||
          (_selectedType == MedicationType.injection &&
              !_requiresReconstitution &&
              _deliveryMethod == 'Vial' &&
              !MedicationMatrix.isValidValue(_selectedType, totalLiquid, 'quantity'))) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Quantity or volume out of valid range (0.01â€“999)')),
        );
        return;
      }

      if (!(await _isNameUnique(name))) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text(MedicationFormConstants.duplicateNameMessage)),
        );
        return;
      }

      final medication = MedicationsCompanion(
        id: drift.Value(widget.medicationId),
        name: drift.Value(name),
        concentration: drift.Value(concentration),
        concentrationUnit: drift.Value(_unit),
        stockQuantity: drift.Value(
          _selectedType == MedicationType.drops
              ? volume
              : _selectedType == MedicationType.injection
              ? totalLiquid
              : quantity,
        ),
        form: drift.Value(_selectedForm!),
      );

      await ref.read(driftServiceProvider).updateMedication(medication);
      ref.invalidate(medicationsProvider);
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Medication updated')),
      );
    } catch (e, stack) {
      debugPrint('Update error: $e\n$stack');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error updating medication: $e')),
      );
    }
  }

  String get _quantityUnit {
    if (_selectedType == MedicationType.tablet) {
      return (double.tryParse(_quantityController.text) ?? 0) == 1 ? 'Tablet' : 'Tablets';
    }
    if (_selectedType == MedicationType.capsule) {
      return (double.tryParse(_quantityController.text) ?? 0) == 1 ? 'Capsule' : 'Capsules';
    }
    if (_selectedType == MedicationType.patch) {
      return (double.tryParse(_quantityController.text) ?? 0) == 1 ? 'Patch' : 'Patches';
    }
    if (_selectedType == MedicationType.suppository) {
      return (double.tryParse(_quantityController.text) ?? 0) == 1 ? 'Suppository' : 'Suppositories';
    }
    return '';
  }

  List<Step> _buildSteps() {
    return [
      Step(
        title: const Text('Select Medication Type'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: Units.forms.map((form) {
                final type = MedicationMatrix.formToType(form);
                return ChoiceChip(
                  label: Text(form),
                  avatar: Icon(_getIconForForm(form)),
                  selected: _selectedForm == form,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedForm = form;
                        _selectedType = type;
                        _unit = MedicationMatrix.getConcentrationUnits(_selectedType).first;
                        _requiresReconstitution = false;
                        _deliveryMethod = 'Pre-filled Syringe';
                        _updateSummary();
                      });
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
        isActive: _currentStep == 0,
        state: _currentStep > 0 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Medication Name'),
        content: TextFormField(
          controller: _nameController,
          decoration: MedicationFormConstants.textFieldDecoration('Medication Name'),
          validator: (value) => value!.isEmpty ? 'Name is required' : null,
          onChanged: (value) => _updateSummary(),
        ),
        isActive: _currentStep == 1,
        state: _currentStep > 1 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Concentration & Unit'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    controller: _concentrationController,
                    decoration: MedicationFormConstants.textFieldDecoration('Concentration'),
                    keyboardType: TextInputType.number,
                    validator: (value) =>
                    value!.isEmpty || double.tryParse(value) == null ? 'Valid number required' : null,
                  ),
                ),
                Column(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.arrow_upward),
                      onPressed: () => _incrementField(_concentrationController),
                    ),
                    IconButton(
                      icon: const Icon(Icons.arrow_downward),
                      onPressed: () => _decrementField(_concentrationController),
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 8,
              children: MedicationMatrix.getConcentrationUnits(_selectedType).map((unitType) {
                return ChoiceChip(
                  label: Text(unitType),
                  selected: _unit == unitType,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _unit = unitType;
                        _updateSummary();
                      });
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
        isActive: _currentStep == 2,
        state: _currentStep > 2 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Quantity/Volume'),
        content: _selectedType == MedicationType.tablet ||
            _selectedType == MedicationType.capsule ||
            _selectedType == MedicationType.patch ||
            _selectedType == MedicationType.suppository
            ? TabletFields(
          concentrationController: _concentrationController,
          quantityController: _quantityController,
          unitController: TextEditingController(text: _unit),
          selectedType: _selectedType,
          onUnitChanged: (value) => setState(() => _unit = value ?? _unit),
          maxWidth: MediaQuery.of(context).size.width * 0.9,
        )
            : _selectedType == MedicationType.injection
            ? InjectionFields(
          concentrationController: _concentrationController,
          unitController: TextEditingController(text: _unit),
          powderAmountController: _powderAmountController,
          solventVolumeController: _solventVolumeController,
          totalLiquidController: _totalLiquidController,
          requiresReconstitution: _requiresReconstitution,
          onReconstitutionChanged: (value) => setState(() => _requiresReconstitution = value),
          onUnitChanged: (value) => setState(() => _unit = value ?? _unit),
          maxWidth: MediaQuery.of(context).size.width * 0.9,
        )
            : _selectedType == MedicationType.drops
            ? DropsFields(
          concentrationController: _concentrationController,
          volumeController: _volumeController,
          unitController: TextEditingController(text: _unit),
          onUnitChanged: (value) => setState(() => _unit = value ?? _unit),
          maxWidth: MediaQuery.of(context).size.width * 0.9,
        )
            : Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    controller: _quantityController,
                    decoration: MedicationFormConstants.textFieldDecoration('Quantity'),
                    keyboardType: TextInputType.number,
                    validator: (value) =>
                    value!.isEmpty || double.tryParse(value) == null ? 'Valid number required' : null,
                  ),
                ),
                Column(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.arrow_upward),
                      onPressed: () => _incrementField(_quantityController, isInteger: true),
                    ),
                    IconButton(
                      icon: const Icon(Icons.arrow_downward),
                      onPressed: () => _decrementField(_quantityController, isInteger: true),
                    ),
                  ],
                ),
              ],
            ),
          ],
        ),
        isActive: _currentStep == 3,
        state: _currentStep > 3 ? StepState.complete : StepState.indexed,
      ),
    ];
  }

  IconData _getIconForForm(String form) {
    switch (form) {
      case 'Tablet':
        return Icons.tablet;
      case 'Capsule':
        return Icons.medication;
      case 'Injection':
        return Icons.medical_services;
      case 'Drops':
        return Icons.water_drop;
      case 'Inhaler':
        return Icons.air;
      case 'Ointment/Cream':
        return Icons.spa;
      case 'Patch':
        return Icons.healing;
      case 'Nasal Spray':
        return Icons.sanitizer;
      case 'Suppository':
        return Icons.medical_information;
      default:
        return Icons.medication;
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_medication == null) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }
    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Medication'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (_summary.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: Text(
                        _summary,
                        style: MedicationFormConstants.summaryStyle(context).copyWith(fontSize: 12),
                      ),
                    ),
                  const SizedBox(height: MedicationFormConstants.sectionSpacing),
                  Stepper(
                    currentStep: _currentStep,
                    onStepContinue: () {
                      if (_currentStep == 0 && _selectedForm == null) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please select a medication type')),
                        );
                        return;
                      }
                      if (_currentStep == 1 && _nameController.text.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please enter a medication name')),
                        );
                        return;
                      }
                      if (_currentStep < _buildSteps().length - 1) {
                        setState(() => _currentStep += 1);
                      } else {
                        _saveMedication();
                      }
                    },
                    onStepCancel: () {
                      if (_currentStep > 0) {
                        setState(() => _currentStep -= 1);
                      }
                    },
                    steps: _buildSteps(),
                    controlsBuilder: (context, details) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 16.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            if (details.onStepCancel != null)
                              TextButton(
                                onPressed: details.onStepCancel,
                                child: const Text('Back'),
                              ),
                            const SizedBox(width: 8),
                            ElevatedButton(
                              onPressed: details.onStepContinue,
                              style: MedicationFormConstants.buttonStyle,
                              child: Text(_currentStep == _buildSteps().length - 1 ? 'Save' : 'Next'),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/screens/medication_info_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../common/utils/formatters.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';

class MedicationsInfoScreen extends ConsumerWidget {
  const MedicationsInfoScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final medicationsAsync = ref.watch(medicationsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Medications'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: medicationsAsync.when(
        data: (meds) => meds.isEmpty
            ? const Center(child: Text('No medications'))
            : ListView.builder(
          itemCount: meds.length,
          itemBuilder: (context, index) {
            final med = meds[index];
            return Card(
              margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 16),
              child: ListTile(
                title: Text(med.name),
                subtitle: Text(
                  '${med.form} - ${Utils.removeTrailingZeros(med.concentration)}${med.concentrationUnit}, Stock: ${Utils.removeTrailingZeros(med.stockQuantity)}',
                ),
                trailing: null,
                onTap: () => Navigator.pushNamed(context, '/medications/edit', arguments: med.id),
              ),
            );
          },
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Card(
          margin: const EdgeInsets.all(16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Text('Error: $e', style: TextStyle(color: Theme.of(context).colorScheme.error)),
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.pushNamed(context, '/medications/add'),
        child: const Icon(Icons.add),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/screens/medication_overview_screen.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../common/utils/formatters.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../../dose/screens/dose_add_screen.dart';
import '../constants/medication_form_constants.dart';
import '../../../widgets/form_widgets.dart';

class MedicationOverviewScreen extends ConsumerWidget {
  final int medicationId;
  const MedicationOverviewScreen({super.key, required this.medicationId});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final medicationAsync = ref.watch(medicationsProvider);
    final dosesAsync = ref.watch(allDosesProvider);

    return medicationAsync.when(
      data: (meds) {
        final med = meds.firstWhere((m) => m.id == medicationId);
        return Scaffold(
          appBar: AppBar(
            title: Text(med.name),
            backgroundColor: Theme.of(context).colorScheme.primary,
            foregroundColor: Colors.white,
            flexibleSpace: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [
                    Theme.of(context).colorScheme.primary,
                    Theme.of(context).colorScheme.primary.withOpacity(0.8),
                  ],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
              ),
            ),
          ),
          body: SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: const Text('Name'),
                    subtitle: Text(med.name),
                    trailing: const Icon(Icons.edit),
                    onTap: () => _editField(context, ref, med, 'name', med.name),
                  ),
                ),
                Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: const Text('Concentration'),
                    subtitle: Text('${Utils.removeTrailingZeros(med.concentration)} ${med.concentrationUnit}'),
                    trailing: const Icon(Icons.edit),
                    onTap: () => _editField(context, ref, med, 'concentration', med.concentration.toString()),
                  ),
                ),
                Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: const Text('Stock Quantity'),
                    subtitle: Text('${Utils.removeTrailingZeros(med.stockQuantity)} ${med.form}'),
                    trailing: const Icon(Icons.edit),
                    onTap: () => _editField(context, ref, med, 'stockQuantity', med.stockQuantity.toString()),
                  ),
                ),
                Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: const Text('Form'),
                    subtitle: Text(med.form),
                    trailing: const Icon(Icons.edit),
                    onTap: () => _editField(context, ref, med, 'form', med.form),
                  ),
                ),
                const SizedBox(height: 16),
                const Text('Doses', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                dosesAsync.when(
                  data: (doses) {
                    final medDoses = doses.where((dose) => dose.medicationId == medicationId).toList();
                    return medDoses.isEmpty
                        ? const Text('No doses added')
                        : Column(
                      children: medDoses.map((dose) => Card(
                        margin: const EdgeInsets.symmetric(vertical: 4),
                        child: ListTile(
                          title: Text(dose.name ?? 'Unnamed'),
                          subtitle: Text('${Utils.removeTrailingZeros(dose.amount)} ${dose.unit}'),
                          trailing: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              IconButton(
                                icon: const Icon(Icons.edit),
                                onPressed: () => Navigator.pushNamed(context, '/doses/edit', arguments: dose.id),
                              ),
                              IconButton(
                                icon: const Icon(Icons.delete),
                                onPressed: () async {
                                  final confirm = await showDialog<bool>(
                                    context: context,
                                    builder: (context) => AlertDialog(
                                      title: const Text('Delete Dose'),
                                      content: const Text('Are you sure you want to delete this dose?'),
                                      actions: [
                                        TextButton(
                                          onPressed: () => Navigator.pop(context, false),
                                          child: const Text('Cancel'),
                                        ),
                                        TextButton(
                                          onPressed: () => Navigator.pop(context, true),
                                          child: const Text('Delete', style: TextStyle(color: Colors.red)),
                                        ),
                                      ],
                                    ),
                                  );
                                  if (confirm == true) {
                                    await ref.read(driftServiceProvider).deleteDose(dose.id);
                                    ref.invalidate(allDosesProvider);
                                  }
                                },
                              ),
                            ],
                          ),
                          onTap: () => Navigator.pushNamed(context, '/doses/edit', arguments: dose.id),
                        ),
                      )).toList(),
                    );
                  },
                  loading: () => const CircularProgressIndicator(),
                  error: (e, _) => Text('Error: $e'),
                ),
                ElevatedButton.icon(
                  icon: const Icon(Icons.add),
                  label: const Text('Add Dose'),
                  onPressed: () => Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => DosesAddScreen(medicationId: medicationId)),
                  ).then((_) => ref.invalidate(allDosesProvider)),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  ),
                ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  icon: const Icon(Icons.calendar_today),
                  label: const Text('Add Schedule'),
                  onPressed: () async {
                    final doses = await ref.read(driftServiceProvider).getDoses(medicationId);
                    if (doses.isEmpty) {
                      await showDialog(
                        context: context,
                        builder: (context) => AlertDialog(
                          title: const Text('No Doses Available'),
                          content: const Text('You must add at least one dose before creating a schedule.'),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context),
                              child: const Text('OK'),
                            ),
                            TextButton(
                              onPressed: () {
                                Navigator.pop(context);
                                Navigator.push(
                                  context,
                                  MaterialPageRoute(builder: (_) => DosesAddScreen(medicationId: medicationId)),
                                );
                              },
                              child: const Text('Add Dose'),
                            ),
                          ],
                        ),
                      );
                      return;
                    }
                    Navigator.pushNamed(context, '/schedules/add', arguments: medicationId);
                  },
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  ),
                ),
              ],
            ),
          ),
        );
      },
      loading: () => const Scaffold(body: Center(child: CircularProgressIndicator())),
      error: (e, _) => Scaffold(body: Center(child: Text('Error: $e'))),
    );
  }

  Future<void> _editField(BuildContext context, WidgetRef ref, Medication med, String field, String initialValue) async {
    final newValue = await FormWidgets.showInputDialog(
      context: context,
      title: 'Edit $field',
      initialValue: initialValue,
      label: field,
      keyboardType: field == 'concentration' || field == 'stockQuantity' ? TextInputType.number : TextInputType.text,
      validator: (value) => value!.isEmpty ? '$field is required' : null,
    );
    if (newValue != null) {
      final update = MedicationsCompanion(
        id: drift.Value(med.id),
        name: field == 'name' ? drift.Value(newValue) : drift.Value(med.name),
        concentration: field == 'concentration' ? drift.Value(double.parse(newValue)) : drift.Value(med.concentration),
        concentrationUnit: drift.Value(med.concentrationUnit),
        stockQuantity: field == 'stockQuantity' ? drift.Value(double.parse(newValue)) : drift.Value(med.stockQuantity),
        form: field == 'form' ? drift.Value(newValue) : drift.Value(med.form),
      );
      await ref.read(driftServiceProvider).updateMedication(update);
      ref.invalidate(medicationsProvider);
    }
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/screens/medication_selection_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../common/utils/formatters.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '/features/schedule/screens/schedule_screen.dart';

class MedicationSelectionScreen extends ConsumerWidget {
  const MedicationSelectionScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final medicationsAsync = ref.watch(medicationsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Select Medication'),
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: medicationsAsync.when(
        data: (meds) => meds.isEmpty
            ? const Center(child: Text('No medications added'))
            : ListView.builder(
          itemCount: meds.length,
          itemBuilder: (context, index) {
            final med = meds[index];
            return ListTile(
              title: Text(med.name),
              subtitle: Text(
                '${Utils.removeTrailingZeros(med.stockQuantity)} x ${Utils.removeTrailingZeros(med.concentration)}${med.concentrationUnit} ${med.form}',
              ),
              onTap: () => Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => ScheduleScreen(medication: med)),
              ),
            );
          },
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('Error: $e')),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/widgets/type_specific_fields/drops_fields.dart
import 'package:flutter/material.dart';
import '../../../../common/medication_matrix.dart';
import '../../constants/medication_form_constants.dart';
import '../medication_form_field.dart';

class DropsFields extends StatelessWidget {
  final TextEditingController concentrationController;
  final TextEditingController volumeController;
  final TextEditingController unitController;
  final ValueChanged<String?> onUnitChanged;
  final double maxWidth;

  const DropsFields({
    super.key,
    required this.concentrationController,
    required this.volumeController,
    required this.unitController,
    required this.onUnitChanged,
    required this.maxWidth,
  });

  void _incrementField(TextEditingController controller) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    controller.text = (currentValue + 1).toStringAsFixed(2).replaceAll(RegExp(r'\.00$'), '');
  }

  void _decrementField(TextEditingController controller) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    if (currentValue > 0) {
      controller.text = (currentValue - 1).toStringAsFixed(2).replaceAll(RegExp(r'\.00$'), '');
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 3,
              child: MedicationFormField(
                controller: concentrationController,
                label: 'Concentration',
                helperText: 'Enter concentration (e.g., mg/mL)',
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                validator: (value) => value!.isEmpty
                    ? MedicationFormConstants.concentrationRequiredMessage
                    : double.tryParse(value) == null
                    ? MedicationFormConstants.invalidNumberMessage
                    : double.parse(value) < 0.01 || double.parse(value) > 999
                    ? 'Concentration out of range (0.01â€“999)'
                    : null,
                maxWidth: screenWidth * 0.9,
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 2,
              child: DropdownButtonFormField<String>(
                value: unitController.text,
                items: ['mg/mL', 'mcg/mL']
                    .map((unit) => DropdownMenuItem(value: unit, child: Text(unit)))
                    .toList(),
                onChanged: onUnitChanged,
                decoration: InputDecoration(
                  labelText: 'Unit',
                  helperText: 'Select unit',
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                  filled: true,
                  fillColor: Colors.grey[100],
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                style: Theme.of(context).textTheme.bodyLarge,
                dropdownColor: Colors.white,
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ],
        ),
        const SizedBox(height: MedicationFormConstants.fieldSpacing),
        MedicationFormField(
          controller: volumeController,
          label: 'Total Volume',
          helperText: 'Enter total volume (mL)',
          keyboardType: const TextInputType.numberWithOptions(decimal: true),
          validator: (value) => value!.isEmpty
              ? 'Volume required'
              : double.tryParse(value) == null
              ? MedicationFormConstants.invalidNumberMessage
              : double.parse(value) < 0.01 || double.parse(value) > 999
              ? 'Volume out of range (0.01â€“999)'
              : null,
          suffix: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Padding(
                padding: EdgeInsets.symmetric(horizontal: 8),
                child: Text('mL'),
              ),
              IconButton(
                icon: const Icon(Icons.remove, size: 20),
                onPressed: () => _decrementField(volumeController),
              ),
              IconButton(
                icon: const Icon(Icons.add, size: 20),
                onPressed: () => _incrementField(volumeController),
              ),
            ],
          ),
          maxWidth: screenWidth * 0.9,
        ),
      ],
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/widgets/type_specific_fields/injection_fields.dart
import 'package:flutter/material.dart';
import '../../constants/medication_form_constants.dart';
import '../medication_form_field.dart';

class InjectionFields extends StatefulWidget {
  final TextEditingController concentrationController;
  final TextEditingController unitController;
  final TextEditingController powderAmountController;
  final TextEditingController solventVolumeController;
  final TextEditingController totalLiquidController;
  final bool requiresReconstitution;
  final ValueChanged<bool> onReconstitutionChanged;
  final ValueChanged<String?> onUnitChanged;
  final double maxWidth;

  const InjectionFields({
    super.key,
    required this.concentrationController,
    required this.unitController,
    required this.powderAmountController,
    required this.solventVolumeController,
    required this.totalLiquidController,
    required this.requiresReconstitution,
    required this.onReconstitutionChanged,
    required this.onUnitChanged,
    required this.maxWidth,
  });

  @override
  InjectionFieldsState createState() => InjectionFieldsState();
}

class InjectionFieldsState extends State<InjectionFields> {
  String _deliveryMethod = 'Pre-filled Syringe';

  void _incrementField(TextEditingController controller) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    controller.text = (currentValue + 1).toStringAsFixed(2).replaceAll(RegExp(r'\.00$'), '');
  }

  void _decrementField(TextEditingController controller) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    if (currentValue > 0) {
      controller.text = (currentValue - 1).toStringAsFixed(2).replaceAll(RegExp(r'\.00$'), '');
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        DropdownButtonFormField<String>(
          value: _deliveryMethod,
          items: ['Pre-filled Syringe', 'Vial']
              .map((method) => DropdownMenuItem(value: method, child: Text(method)))
              .toList(),
          onChanged: (value) => setState(() => _deliveryMethod = value!),
          decoration: InputDecoration(
            labelText: 'Delivery Method',
            helperText: 'Choose syringe or vial',
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
            filled: true,
            fillColor: Colors.grey[100],
            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          ),
          style: Theme.of(context).textTheme.bodyLarge,
          dropdownColor: Colors.white,
          borderRadius: BorderRadius.circular(12),
        ),
        const SizedBox(height: MedicationFormConstants.fieldSpacing),
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 3,
              child: MedicationFormField(
                controller: widget.concentrationController,
                label: 'Concentration',
                helperText: 'Enter concentration (mg or mcg)',
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                validator: (value) => value!.isEmpty
                    ? MedicationFormConstants.concentrationRequiredMessage
                    : double.tryParse(value) == null
                    ? MedicationFormConstants.invalidNumberMessage
                    : double.parse(value) < 0.0001 || double.parse(value) > 999
                    ? 'Concentration out of range (0.0001â€“999)'
                    : null,
                maxWidth: screenWidth * 0.9,
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 2,
              child: DropdownButtonFormField<String>(
                value: widget.unitController.text,
                items: ['mg', 'mcg']
                    .map((unit) => DropdownMenuItem(value: unit, child: Text(unit)))
                    .toList(),
                onChanged: widget.onUnitChanged,
                decoration: InputDecoration(
                  labelText: 'Unit',
                  helperText: 'Select unit',
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                  filled: true,
                  fillColor: Colors.grey[100],
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                style: Theme.of(context).textTheme.bodyLarge,
                dropdownColor: Colors.white,
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ],
        ),
        if (_deliveryMethod != 'Pre-filled Syringe') ...[
          const SizedBox(height: MedicationFormConstants.fieldSpacing),
          MedicationFormField(
            controller: widget.totalLiquidController,
            label: 'Total Volume',
            helperText: 'Enter total volume (mL)',
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            validator: (value) => value!.isEmpty
                ? 'Total volume required for vials'
                : double.tryParse(value) == null
                ? MedicationFormConstants.invalidNumberMessage
                : double.parse(value) < 0.01 || double.parse(value) > 999
                ? 'Volume out of range (0.01â€“999)'
                : null,
            suffix: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Padding(
                  padding: EdgeInsets.symmetric(horizontal: 8),
                  child: Text('mL'),
                ),
                IconButton(
                  icon: const Icon(Icons.remove, size: 20),
                  onPressed: () => _decrementField(widget.totalLiquidController),
                ),
                IconButton(
                  icon: const Icon(Icons.add, size: 20),
                  onPressed: () => _incrementField(widget.totalLiquidController),
                ),
              ],
            ),
            maxWidth: screenWidth * 0.9,
          ),
        ],
        if (_deliveryMethod == 'Vial') ...[
          const SizedBox(height: MedicationFormConstants.fieldSpacing),
          CheckboxListTile(
            title: const Text('Requires Reconstitution'),
            value: widget.requiresReconstitution,
            onChanged: (value) => widget.onReconstitutionChanged(value!),
          ),
          if (widget.requiresReconstitution) ...[
            const SizedBox(height: MedicationFormConstants.fieldSpacing),
            MedicationFormField(
              controller: widget.powderAmountController,
              label: MedicationFormConstants.powderAmountLabel,
              helperText: 'Enter powder amount (mg)',
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
              validator: (value) => value!.isEmpty
                  ? MedicationFormConstants.reconstitutionRequiredMessage
                  : double.tryParse(value) == null
                  ? MedicationFormConstants.invalidNumberMessage
                  : double.parse(value) <= 0
                  ? 'Powder amount must be greater than 0'
                  : null,
              maxWidth: screenWidth * 0.9,
            ),
            const SizedBox(height: MedicationFormConstants.fieldSpacing),
            MedicationFormField(
              controller: widget.solventVolumeController,
              label: MedicationFormConstants.solventVolumeLabel,
              helperText: 'Enter solvent volume (mL)',
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
              validator: (value) => value!.isEmpty
                  ? MedicationFormConstants.reconstitutionRequiredMessage
                  : double.tryParse(value) == null
                  ? MedicationFormConstants.invalidNumberMessage
                  : double.parse(value) <= 0
                  ? 'Solvent volume must be greater than 0'
                  : null,
              maxWidth: screenWidth * 0.9,
            ),
          ],
        ],
      ],
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/widgets/type_specific_fields/tablet_fields.dart
import 'package:flutter/material.dart';
import '../../../../common/medication_matrix.dart';
import '../../constants/medication_form_constants.dart';
import '../medication_form_field.dart';

class TabletFields extends StatelessWidget {
  final TextEditingController concentrationController;
  final TextEditingController quantityController;
  final TextEditingController unitController;
  final MedicationType selectedType;
  final ValueChanged<String?> onUnitChanged;
  final double maxWidth;

  const TabletFields({
    super.key,
    required this.concentrationController,
    required this.quantityController,
    required this.unitController,
    required this.selectedType,
    required this.onUnitChanged,
    required this.maxWidth,
  });

  void _incrementField(TextEditingController controller) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    controller.text = (currentValue + 1).toStringAsFixed(2).replaceAll(RegExp(r'\.00$'), '');
  }

  void _decrementField(TextEditingController controller) {
    final currentValue = double.tryParse(controller.text) ?? 0;
    if (currentValue > 0) {
      controller.text = (currentValue - 1).toStringAsFixed(2).replaceAll(RegExp(r'\.00$'), '');
    }
  }

  @override
  Widget build(BuildContext context) {
    final quantity = double.tryParse(quantityController.text) ?? 1;
    final screenWidth = MediaQuery.of(context).size.width;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 3,
              child: MedicationFormField(
                controller: concentrationController,
                label: MedicationFormConstants.concentrationLabel,
                helperText: 'Enter concentration per ${selectedType.name}',
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                validator: (value) => value!.isEmpty
                    ? MedicationFormConstants.concentrationRequiredMessage
                    : double.tryParse(value) == null
                    ? MedicationFormConstants.invalidNumberMessage
                    : null,
                maxWidth: screenWidth * 0.9, // Consistent width
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 2,
              child: DropdownButtonFormField<String>(
                value: unitController.text,
                items: MedicationMatrix.getConcentrationUnits(selectedType)
                    .map((unit) => DropdownMenuItem(value: unit, child: Text(unit)))
                    .toList(),
                onChanged: onUnitChanged,
                decoration: InputDecoration(
                  labelText: 'Unit',
                  helperText: 'Select unit', // Add helper text
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                  filled: true,
                  fillColor: Colors.grey[100],
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: MedicationFormConstants.fieldSpacing),
        MedicationFormField(
          controller: quantityController,
          label: MedicationFormConstants.quantityLabel,
          helperText: 'Enter number of ${quantity == 1 ? 'Tablet' : 'Tablets'}',
          keyboardType: const TextInputType.numberWithOptions(decimal: true),
          validator: (value) => value!.isEmpty
              ? MedicationFormConstants.quantityRequiredMessage
              : double.tryParse(value) == null
              ? MedicationFormConstants.invalidNumberMessage
              : null,
          suffix: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Text(quantity == 1 ? 'Tablet' : 'Tablets'),
              ),
              IconButton(
                icon: const Icon(Icons.remove, size: 20),
                onPressed: () => _decrementField(quantityController),
              ),
              IconButton(
                icon: const Icon(Icons.add, size: 20),
                onPressed: () => _incrementField(quantityController),
              ),
            ],
          ),
          maxWidth: screenWidth * 0.9, // Consistent width
        ),
      ],
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/widgets/medication_form_card.dart
import 'package:flutter/material.dart';
import '../../../common/form_styles.dart';

class MedicationFormCard extends StatelessWidget {
  final Widget child;

  const MedicationFormCard({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      margin: EdgeInsets.zero, // Remove margins for full width
      child: Container(
        width: FormStyles.fullWidthField, // Use full-width constant
        padding: const EdgeInsets.all(16.0),
        child: child,
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/widgets/medication_form_field.dart
import 'package:flutter/material.dart';
import '../../../common/form_styles.dart';
import '../../../common/utils/formatters.dart';
import 'medication_form_card.dart';

class MedicationFormField extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final String helperText;
  final int? helperMaxLines;
  final String? Function(String?)? validator;
  final TextInputType? keyboardType;
  final Widget? suffix;
  final double maxWidth;

  const MedicationFormField({
    super.key,
    required this.controller,
    required this.label,
    required this.helperText,
    this.helperMaxLines,
    this.validator,
    this.keyboardType,
    this.suffix,
    required this.maxWidth,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Expanded(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: maxWidth),
                child: TextFormField(
                  controller: controller,
                  decoration: InputDecoration(
                    labelText: label,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    suffixIcon: suffix,
                  ),
                  keyboardType: keyboardType,
                  validator: validator,
                  inputFormatters: keyboardType == const TextInputType.numberWithOptions(decimal: true)
                      ? [DecimalTextInputFormatter()]
                      : null,
                ),
              ),
            ),
          ],
        ),
        if (helperText.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(left: 16.0, top: 4.0),
            child: Text(
              helperText,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              maxLines: helperMaxLines ?? 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),
      ],
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/medication/widgets/medication_form_widgets.dart
import 'package:flutter/material.dart';
import '../../../common/form_styles.dart';
import '../../../common/medication_matrix.dart';
import '../constants/medication_form_constants.dart';
import 'medication_form_field.dart';
import 'medication_form_card.dart';
import 'type_specific_fields/tablet_fields.dart';
import 'type_specific_fields/injection_fields.dart';
import 'type_specific_fields/drops_fields.dart';

class MedicationFormWidgets {
  static Widget buildTypeDropdown({
    required BuildContext context,
    required String? value,
    required ValueChanged<String?> onChanged,
  }) {
    return MedicationFormCard(
      child: ConstrainedBox(
        constraints: const BoxConstraints(minHeight: 72.0),
        child: DropdownButtonFormField<String>(
          decoration: MedicationFormConstants.dropdownDecoration.copyWith(
            labelText: null,
            hint: const Text('Select Medication Type'),
            helperText: 'Choose Medication Type',
            helperMaxLines: 2,
          ),
          value: value,
          items: MedicationFormConstants.medicationTypes
              .map((item) => DropdownMenuItem(value: item, child: Text(item)))
              .toList(),
          onChanged: onChanged,
          dropdownColor: Colors.white,
          menuMaxHeight: 300,
          style: Theme.of(context).textTheme.bodyLarge,
          borderRadius: BorderRadius.circular(12),
          validator: (value) => value == null ? MedicationFormConstants.typeRequiredMessage : null,
        ),
      ),
    );
  }

  static Widget buildNameField({
    required BuildContext context,
    required TextEditingController controller,
    required double maxWidth,
  }) {
    return MedicationFormCard(
      child: MedicationFormField(
        controller: controller,
        label: MedicationFormConstants.nameLabel,
        helperText: 'Enter the name of the Medication',
        helperMaxLines: 2,
        validator: (value) => value!.isEmpty ? MedicationFormConstants.nameRequiredMessage : null,
        maxWidth: maxWidth,
      ),
    );
  }

  static Widget buildConcentrationField({
    required BuildContext context,
    required TextEditingController controller,
    required String selectedForm,
    required MedicationType selectedType,
    required String unit,
    required ValueChanged<String?> onUnitChanged,
    required VoidCallback onIncrement,
    required VoidCallback onDecrement,
    required double maxWidth,
  }) {
    return MedicationFormCard(
      child: MedicationFormField(
        controller: controller,
        label: MedicationFormConstants.concentrationLabel,
        helperText: 'Enter the concentration of the medication per $selectedForm',
        helperMaxLines: 2,
        keyboardType: const TextInputType.numberWithOptions(decimal: true),
        validator: (value) => value!.isEmpty
            ? MedicationFormConstants.concentrationRequiredMessage
            : double.tryParse(value) == null
            ? MedicationFormConstants.invalidNumberMessage
            : null,
        suffix: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8),
              child: DropdownButton<String>(
                value: unit,
                items: MedicationMatrix.getConcentrationUnits(selectedType)
                    .map((unit) => DropdownMenuItem(value: unit, child: Text(unit)))
                    .toList(),
                onChanged: onUnitChanged,
              ),
            ),
            Padding(
              padding: FormStyles.buttonPadding,
              child: IconButton(
                icon: const Icon(Icons.remove, size: 20),
                onPressed: onDecrement,
              ),
            ),
            Padding(
              padding: FormStyles.buttonPadding,
              child: IconButton(
                icon: const Icon(Icons.add, size: 20),
                onPressed: onIncrement,
              ),
            ),
          ],
        ),
        maxWidth: maxWidth,
      ),
    );
  }

  static Widget buildQuantityField({
    required BuildContext context,
    required TextEditingController controller,
    required String selectedForm,
    required VoidCallback onIncrement,
    required VoidCallback onDecrement,
    required double maxWidth,
  }) {
    return MedicationFormCard(
      child: MedicationFormField(
        controller: controller,
        label: MedicationFormConstants.quantityLabel,
        helperText: 'Enter the amount of $selectedForm/s',
        helperMaxLines: 2,
        keyboardType: const TextInputType.numberWithOptions(decimal: true),
        validator: (value) => value!.isEmpty
            ? MedicationFormConstants.quantityRequiredMessage
            : double.tryParse(value) == null
            ? MedicationFormConstants.invalidNumberMessage
            : null,
        suffix: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8),
              child: Text(
                MedicationFormConstants.unitsLabel,
                style: Theme.of(context).textTheme.bodyMedium,
              ),
            ),
            Padding(
              padding: FormStyles.buttonPadding,
              child: IconButton(
                icon: const Icon(Icons.remove, size: 20),
                onPressed: onDecrement,
              ),
            ),
            Padding(
              padding: FormStyles.buttonPadding,
              child: IconButton(
                icon: const Icon(Icons.add, size: 20),
                onPressed: onIncrement,
              ),
            ),
          ],
        ),
        maxWidth: maxWidth,
      ),
    );
  }

  static Widget buildTypeSpecificFields({
    required BuildContext context,
    required MedicationType type,
    required TextEditingController concentrationController,
    required TextEditingController quantityController,
    required TextEditingController unitController,
    required TextEditingController powderAmountController,
    required TextEditingController solventVolumeController,
    required TextEditingController volumeController,
    required TextEditingController totalLiquidController,
    required bool requiresReconstitution,
    required ValueChanged<bool> onReconstitutionChanged,
    required ValueChanged<String?> onUnitChanged,
    required double maxWidth,
  }) {
    switch (type) {
      case MedicationType.tablet:
      case MedicationType.capsule:
        return TabletFields(
          concentrationController: concentrationController,
          quantityController: quantityController,
          unitController: unitController,
          selectedType: type,
          onUnitChanged: onUnitChanged,
          maxWidth: maxWidth,
        );
      case MedicationType.injection:
        return InjectionFields(
          concentrationController: concentrationController,
          unitController: unitController,
          powderAmountController: powderAmountController,
          solventVolumeController: solventVolumeController,
          totalLiquidController: totalLiquidController,
          requiresReconstitution: requiresReconstitution,
          onReconstitutionChanged: onReconstitutionChanged,
          onUnitChanged: onUnitChanged,
          maxWidth: maxWidth,
        );
      case MedicationType.drops:
        return DropsFields(
          concentrationController: concentrationController,
          volumeController: volumeController,
          unitController: unitController,
          onUnitChanged: onUnitChanged,
          maxWidth: maxWidth,
        );
      default:
        return const SizedBox.shrink();
    }
  }
}

// --- FILE BREAK ---

// File: lib/features/schedule/constants/schedule_form_constants.dart
// lib/features/schedule/constants/schedule_form_constants.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../../../common/utils/formatters.dart'; // Add import
import '../../../data/database.dart';

class ScheduleFormConstants {
  // Strings
  static const String defaultName = 'Unnamed Schedule';
  static const String defaultFrequency = 'Daily';
  static const String dailyFrequency = 'Daily';
  static const String weeklyFrequency = 'Weekly';
  static const String nameLabel = 'Schedule Name';
  static const String frequencyLabel = 'Frequency';
  static const String daysLabel = 'Days';
  static const String doseLabel = 'Dose (Optional)';
  static const String doseSelectLabel = 'Select Dose';
  static const String noDose = 'None';
  static const String nameHelper = 'Enter a name for the schedule (e.g., Morning Dose)';
  static const String nameRequiredMessage = 'Schedule Name is required';
  static const String frequencyRequiredMessage = 'Frequency is required';
  static const String noDaysSelectedMessage = 'Please select at least one day';
  static const String scheduleSavedMessage = 'Schedule saved';
  static const String saveButton = 'Save Schedule';
  static const List<String> frequencies = ['Daily', 'Weekly'];
  static const List<String> daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

  static String screenTitle(String medicationName) => 'Schedule for $medicationName';
  static String timeLabel(TimeOfDay time) => 'Time: ${DateFormat.jm().format(DateTime(2023, 1, 1, time.hour, time.minute))}';
  static String notificationTitle(String medicationName) => 'Medication Reminder: $medicationName';
  static String notificationBodyWithDose(double amount, String unit, String name) =>
      'Time to take ${Utils.removeTrailingZeros(amount)} $unit ($name)';
  static String notificationBodyWithoutDose(String name) => 'Schedule: $name';
  static String doseDisplay(Dose dose) =>
      '${Utils.removeTrailingZeros(dose.amount)} ${dose.unit == 'Tablet' ? 'Tablet${dose.amount == 1 ? '' : 's'}' : dose.unit} (${dose.name ?? 'Unnamed'})';
  static String errorSavingMessage(Object error) => 'Error saving schedule: $error';

  // Paddings and Spacings
  static const EdgeInsets formPadding = EdgeInsets.all(16.0);
  static const EdgeInsets cardPadding = EdgeInsets.symmetric(horizontal: 16, vertical: 8);
  static const EdgeInsets cardContentPadding = EdgeInsets.symmetric(horizontal: 16, vertical: 8);
  static const double fieldSpacing = 16.0;
  static const double buttonSpacing = 32.0;
  static const double innerSpacing = 8.0;

  // Card Styling
  static const double cardElevation = 2.0;
  static const RoundedRectangleBorder cardShape = RoundedRectangleBorder(
    borderRadius: BorderRadius.all(Radius.circular(12)),
  );

  // Styles
  static TextStyle sectionTitleStyle(BuildContext context) => Theme.of(context).textTheme.bodyLarge!.copyWith(
    fontWeight: FontWeight.bold,
  );

  static TextStyle buttonTextStyle(BuildContext context) => Theme.of(context).textTheme.bodyLarge!.copyWith(
    color: Colors.white,
  );

  // Decorations
  static InputDecoration textFieldDecoration(String label, String? helperText) => InputDecoration(
    labelText: label,
    helperText: helperText,
    border: const OutlineInputBorder(borderRadius: BorderRadius.all(Radius.circular(12))),
    filled: true,
    fillColor: Colors.grey[100],
    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
  );

  static InputDecoration dropdownDecoration(String label) => InputDecoration(
    labelText: label,
    helperText: label.contains('Dose') ? 'Choose a dose for this schedule (required)' : null,
    border: const OutlineInputBorder(borderRadius: BorderRadius.all(Radius.circular(12))),
    filled: true,
    fillColor: Colors.grey[100],
    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
  );

  // Button Style
  static final ButtonStyle buttonStyle = ElevatedButton.styleFrom(
    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
    shape: const RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(12))),
  );

  // AppBar Gradient
  static BoxDecoration appBarGradient(BuildContext context) => BoxDecoration(
    gradient: LinearGradient(
      colors: [
        Theme.of(context).colorScheme.primary,
        Theme.of(context).colorScheme.primary.withOpacity(0.8),
      ],
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
    ),
  );
}

// --- FILE BREAK ---

// File: lib/features/schedule/screens/schedule_add_screen.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logging/logging.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../../../services/notification_service.dart';
import '../../medication/constants/medication_form_constants.dart';

class SchedulesAddScreen extends ConsumerStatefulWidget {
  final int? medicationId;

  const SchedulesAddScreen({super.key, this.medicationId});

  @override
  ConsumerState<SchedulesAddScreen> createState() => _SchedulesAddScreenState();
}

class _SchedulesAddScreenState extends ConsumerState<SchedulesAddScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  int? _selectedMedicationId;
  String? _selectedMedicationName;
  TimeOfDay _selectedTime = TimeOfDay.now();
  List<String> _selectedDays = [];
  bool _notificationsEnabled = true;
  int? _selectedDoseId;
  int _currentStep = 0;
  List<Medication> _medications = [];
  List<Dose> _doses = [];
  final Logger _logger = Logger('SchedulesAddScreen');

  @override
  void initState() {
    super.initState();
    _logger.info('Initializing SchedulesAddScreen with medicationId: ${widget.medicationId}');
    if (widget.medicationId != null) {
      _selectedMedicationId = widget.medicationId;
      _loadMedications().then((_) {
        final med = _medications.firstWhere(
              (m) => m.id == widget.medicationId!,
          orElse: () => Medication(id: -1, name: 'Not Found', concentration: 0, concentrationUnit: '', stockQuantity: 0, form: ''),
        );
        if (med.id != -1) {
          setState(() {
            _selectedMedicationId = med.id;
            _selectedMedicationName = med.name;
            _logger.info('Pre-selected medication: ${med.name} (ID: ${med.id})');
          });
          _loadDoses();
        } else {
          _logger.severe('Medication ID ${widget.medicationId} not found');
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Medication not found')),
          );
        }
      });
    } else {
      _loadMedications();
    }
    _nameController.addListener(() => setState(() {}));
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  Future<void> _loadMedications() async {
    final meds = await ref.read(driftServiceProvider).getMedications();
    setState(() {
      _medications = meds;
    });
    if (_selectedMedicationId != null) {
      _loadDoses();
    }
  }

  Future<void> _loadDoses() async {
    if (_selectedMedicationId == null) return;
    final doses = await ref.read(driftServiceProvider).getDoses(_selectedMedicationId!);
    setState(() {
      _doses = doses;
    });
  }

  String get _summary {
    if (_selectedMedicationName == null || _selectedDays.isEmpty) return '';
    final doseText = _selectedDoseId != null ? 'Dose ID: $_selectedDoseId, ' : '';
    return 'Schedule: $_selectedMedicationName at ${_selectedTime.format(context)} on ${_selectedDays.join(', ')}\n$doseText: ${_nameController.text.isEmpty ? 'Unnamed' : _nameController.text}';
  }

  void _saveSchedule() async {
    if (!_formKey.currentState!.validate()) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Please complete all required fields')));
      return;
    }

    if (_selectedMedicationId == null) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Please select a medication')));
      return;
    }

    if (_selectedDays.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Please select at least one day')));
      return;
    }

    final notificationId = '${_selectedMedicationId}_${DateTime.now().millisecondsSinceEpoch}';
    final schedule = SchedulesCompanion(
      medicationId: drift.Value(_selectedMedicationId!),
      medicationName: drift.Value(_selectedMedicationName!),
      frequency: drift.Value('Daily'),
      time: drift.Value(DateTime.now().copyWith(hour: _selectedTime.hour, minute: _selectedTime.minute)),
      days: drift.Value(_selectedDays),
      name: drift.Value(_nameController.text.isEmpty ? 'Unnamed' : _nameController.text),
      doseId: _selectedDoseId != null ? drift.Value(_selectedDoseId!) : const drift.Value.absent(),
      notificationsEnabled: drift.Value(_notificationsEnabled),
      notificationId: drift.Value(notificationId),
    );

    try {
      _logger.info('Saving schedule: $schedule');
      final scheduleId = await ref.read(driftServiceProvider).addSchedule(schedule);
      if (_notificationsEnabled) {
        await ref
            .read(notificationServiceProvider)
            .scheduleNotification(
              id: notificationId,
              title: 'MedMinder: $_selectedMedicationName',
              body: 'Time for your dose!',
              scheduledTime: DateTime.now().copyWith(hour: _selectedTime.hour, minute: _selectedTime.minute),
              days: _selectedDays,
            );
        _logger.info('Scheduled notification for schedule ID: $scheduleId');
      }
      ref.invalidate(schedulesProvider);
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Schedule added')));
    } catch (e, stack) {
      _logger.severe('Error adding schedule: $e\n$stack');
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error adding schedule: $e')));
    }
  }

  List<Step> _buildSteps() {
    return [
      Step(
        title: const Text('Select Medication'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: _medications.map((med) {
                return ChoiceChip(
                  label: Text(med.name),
                  selected: _selectedMedicationId == med.id,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedMedicationId = med.id;
                        _selectedMedicationName = med.name;
                        _selectedDoseId = null;
                        _doses = [];
                      });
                      _loadDoses();
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
        isActive: _currentStep == 0,
        state: _currentStep > 0 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Select Dose (Optional)'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            DropdownButtonFormField<int>(
              value: _selectedDoseId,
              items: [
                const DropdownMenuItem<int>(value: null, child: Text('None')),
                ..._doses.map(
                  (dose) => DropdownMenuItem<int>(
                    value: dose.id,
                    child: Text('${dose.amount} ${dose.unit} (${dose.name ?? 'Unnamed'})'),
                  ),
                ),
              ],
              onChanged: (value) {
                setState(() {
                  _selectedDoseId = value;
                });
              },
              decoration: const InputDecoration(labelText: 'Dose', border: OutlineInputBorder()),
            ),
          ],
        ),
        isActive: _currentStep == 1,
        state: _currentStep > 1 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Schedule Name'),
        content: TextFormField(
          controller: _nameController,
          decoration: const InputDecoration(
            labelText: 'Schedule Name',
            hintText: 'e.g., Morning Dose',
            border: OutlineInputBorder(),
          ),
        ),
        isActive: _currentStep == 2,
        state: _currentStep > 2 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Schedule Time'),
        content: ElevatedButton(
          onPressed: () async {
            final time = await showTimePicker(context: context, initialTime: _selectedTime);
            if (time != null) {
              setState(() {
                _selectedTime = time;
              });
            }
          },
          child: Text('Select Time: ${_selectedTime.format(context)}'),
        ),
        isActive: _currentStep == 3,
        state: _currentStep > 3 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Select Days'),
        content: Wrap(
          spacing: 8,
          runSpacing: 8,
          children: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day) {
            return ChoiceChip(
              label: Text(day),
              selected: _selectedDays.contains(day),
              onSelected: (selected) {
                setState(() {
                  if (selected) {
                    _selectedDays.add(day);
                  } else {
                    _selectedDays.remove(day);
                  }
                });
              },
            );
          }).toList(),
        ),
        isActive: _currentStep == 4,
        state: _currentStep > 4 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Notifications'),
        content: SwitchListTile(
          title: const Text('Enable Notifications'),
          value: _notificationsEnabled,
          onChanged: (value) => setState(() {
            _notificationsEnabled = value;
          }),
        ),
        isActive: _currentStep == 5,
        state: _currentStep > 5 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Confirm'),
        content: Text(_summary.isEmpty ? 'Please complete all steps' : _summary),
        isActive: _currentStep == 6,
        state: _currentStep > 6 ? StepState.complete : StepState.indexed,
      ),
    ];
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Add Schedule'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [Theme.of(context).colorScheme.primary, Theme.of(context).colorScheme.primary.withOpacity(0.8)],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (_summary.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: Text(
                        _summary,
                        style: MedicationFormConstants.summaryStyle(context).copyWith(fontSize: 12),
                      ),
                    ),
                  const SizedBox(height: MedicationFormConstants.sectionSpacing),
                  Stepper(
                    currentStep: _currentStep,
                    onStepContinue: () {
                      if (_currentStep == 0 && _selectedMedicationId == null) {
                        ScaffoldMessenger.of(
                          context,
                        ).showSnackBar(const SnackBar(content: Text('Please select a medication')));
                        return;
                      }
                      if (_currentStep == 4 && _selectedDays.isEmpty) {
                        ScaffoldMessenger.of(
                          context,
                        ).showSnackBar(const SnackBar(content: Text('Please select at least one day')));
                        return;
                      }
                      if (_currentStep < _buildSteps().length - 1) {
                        setState(() => _currentStep += 1);
                      } else {
                        _saveSchedule();
                      }
                    },
                    onStepCancel: () {
                      if (_currentStep > 0) {
                        setState(() => _currentStep -= 1);
                      }
                    },
                    steps: _buildSteps(),
                    controlsBuilder: (context, details) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 16.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            if (details.onStepCancel != null)
                              TextButton(onPressed: details.onStepCancel, child: const Text('Back')),
                            const SizedBox(width: 8),
                            ElevatedButton(
                              onPressed: details.onStepContinue,
                              style: MedicationFormConstants.buttonStyle,
                              child: Text(_currentStep == _buildSteps().length - 1 ? 'Save' : 'Next'),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/schedule/screens/schedule_edit_screen.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../../../services/notification_service.dart';
import '../../medication/constants/medication_form_constants.dart';

class SchedulesEditScreen extends ConsumerStatefulWidget {
  final int scheduleId;
  const SchedulesEditScreen({super.key, required this.scheduleId});

  @override
  ConsumerState<SchedulesEditScreen> createState() => _SchedulesEditScreenState();
}

class _SchedulesEditScreenState extends ConsumerState<SchedulesEditScreen> {
  final _formKey = GlobalKey<FormState>();
  int? _selectedMedicationId;
  String? _selectedMedicationName;
  TimeOfDay _selectedTime = TimeOfDay.now();
  List<String> _selectedDays = [];
  bool _notificationsEnabled = true;
  int _currentStep = 0;
  List<Medication> _medications = [];
  Schedule? _schedule;

  @override
  void initState() {
    super.initState();
    _loadMedications();
    _loadSchedule();
  }

  Future<void> _loadMedications() async {
    final meds = await ref.read(driftServiceProvider).getMedications();
    setState(() {
      _medications = meds;
    });
  }

  Future<void> _loadSchedule() async {
    final schedule = await ref.read(driftServiceProvider).getScheduleById(widget.scheduleId);
    if (schedule != null) {
      setState(() {
        _schedule = schedule;
        _selectedMedicationId = schedule.medicationId;
        _selectedMedicationName = schedule.medicationName;
        _selectedTime = TimeOfDay.fromDateTime(schedule.time);
        _selectedDays = schedule.days;
        _notificationsEnabled = schedule.notificationsEnabled;
      });
    }
  }

  String get _summary {
    if (_selectedMedicationName == null || _selectedDays.isEmpty) return '';
    return 'Schedule: $_selectedMedicationName at ${_selectedTime.format(context)} on ${_selectedDays.join(', ')}';
  }

  void _saveSchedule() async {
    if (!_formKey.currentState!.validate()) return;

    if (_selectedMedicationId == null || _selectedDays.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a medication and days')),
      );
      return;
    }

    final schedule = SchedulesCompanion(
      id: drift.Value(widget.scheduleId),
      medicationId: drift.Value(_selectedMedicationId!),
      medicationName: drift.Value(_selectedMedicationName!),
      time: drift.Value(DateTime.now().copyWith(hour: _selectedTime.hour, minute: _selectedTime.minute)),
      days: drift.Value(_selectedDays),
      notificationsEnabled: drift.Value(_notificationsEnabled),
      notificationId: drift.Value(_schedule?.notificationId ?? '${_selectedMedicationId}_${DateTime.now().millisecondsSinceEpoch}'),
    );

    try {
      await ref.read(driftServiceProvider).updateSchedule(widget.scheduleId, schedule);
      if (_notificationsEnabled && schedule.notificationId.value != null) {
        await ref.read(notificationServiceProvider).scheduleNotification(
          id: schedule.notificationId.value!,
          title: 'MedMinder: $_selectedMedicationName',
          body: 'Time for your dose!',
          scheduledTime: DateTime.now().copyWith(hour: _selectedTime.hour, minute: _selectedTime.minute),
          days: _selectedDays,
        );
      } else if (!_notificationsEnabled && _schedule?.notificationId != null) {
        await ref.read(notificationServiceProvider).cancelNotification(_schedule!.notificationId!);
      }
      ref.invalidate(schedulesProvider);
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Schedule updated')),
      );
    } catch (e, stack) {
      debugPrint('Update error: $e\n$stack');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error updating schedule: $e')),
      );
    }
  }

  List<Step> _buildSteps() {
    return [
      Step(
        title: const Text('Select Medication'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: _medications.map((med) {
                return ChoiceChip(
                  label: Text(med.name),
                  selected: _selectedMedicationId == med.id,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedMedicationId = med.id;
                        _selectedMedicationName = med.name;
                      });
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
        isActive: _currentStep == 0,
        state: _currentStep > 0 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Schedule Time'),
        content: ElevatedButton(
          onPressed: () async {
            final time = await showTimePicker(
              context: context,
              initialTime: _selectedTime,
            );
            if (time != null) {
              setState(() {
                _selectedTime = time;
              });
            }
          },
          child: Text('Select Time: ${_selectedTime.format(context)}'),
        ),
        isActive: _currentStep == 1,
        state: _currentStep > 1 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Select Days'),
        content: Wrap(
          spacing: 8,
          runSpacing: 8,
          children: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day) {
            return ChoiceChip(
              label: Text(day),
              selected: _selectedDays.contains(day),
              onSelected: (selected) {
                setState(() {
                  if (selected) {
                    _selectedDays.add(day);
                  } else {
                    _selectedDays.remove(day);
                  }
                });
              },
            );
          }).toList(),
        ),
        isActive: _currentStep == 2,
        state: _currentStep > 2 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Notifications'),
        content: SwitchListTile(
          title: const Text('Enable Notifications'),
          value: _notificationsEnabled,
          onChanged: (value) => setState(() {
            _notificationsEnabled = value;
          }),
        ),
        isActive: _currentStep == 3,
        state: _currentStep > 3 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Confirm'),
        content: Text(_summary.isEmpty ? 'Please complete all steps' : _summary),
        isActive: _currentStep == 4,
        state: _currentStep > 4 ? StepState.complete : StepState.indexed,
      ),
    ];
  }

  @override
  Widget build(BuildContext context) {
    if (_schedule == null) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }
    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Schedule'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                Theme.of(context).colorScheme.primary,
                Theme.of(context).colorScheme.primary.withOpacity(0.8),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (_summary.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: Text(
                        _summary,
                        style: MedicationFormConstants.summaryStyle(context).copyWith(fontSize: 12),
                      ),
                    ),
                  const SizedBox(height: MedicationFormConstants.sectionSpacing),
                  Stepper(
                    currentStep: _currentStep,
                    onStepContinue: () {
                      if (_currentStep == 0 && _selectedMedicationId == null) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please select a medication')),
                        );
                        return;
                      }
                      if (_currentStep == 2 && _selectedDays.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please select at least one day')),
                        );
                        return;
                      }
                      if (_currentStep < _buildSteps().length - 1) {
                        setState(() => _currentStep += 1);
                      } else {
                        _saveSchedule();
                      }
                    },
                    onStepCancel: () {
                      if (_currentStep > 0) {
                        setState(() => _currentStep -= 1);
                      }
                    },
                    steps: _buildSteps(),
                    controlsBuilder: (context, details) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 16.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            if (details.onStepCancel != null)
                              TextButton(
                                onPressed: details.onStepCancel,
                                child: const Text('Back'),
                              ),
                            const SizedBox(width: 8),
                            ElevatedButton(
                              onPressed: details.onStepContinue,
                              style: MedicationFormConstants.buttonStyle,
                              child: Text(_currentStep == _buildSteps().length - 1 ? 'Save' : 'Next'),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/schedule/screens/schedule_info_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../../../services/dose_service.dart';

enum ScheduleView { list, day, week, month }

class SchedulesInfoScreen extends ConsumerStatefulWidget {
  const SchedulesInfoScreen({super.key});

  @override
  ConsumerState<SchedulesInfoScreen> createState() => _SchedulesInfoScreenState();
}

class _SchedulesInfoScreenState extends ConsumerState<SchedulesInfoScreen> {
  ScheduleView _currentView = ScheduleView.list;

  @override
  Widget build(BuildContext context) {
    final schedulesAsync = ref.watch(schedulesProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Schedules'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [Theme.of(context).colorScheme.primary, Theme.of(context).colorScheme.primary.withOpacity(0.8)],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
        actions: [
          DropdownButton<ScheduleView>(
            value: _currentView,
            icon: const Icon(Icons.view_list, color: Colors.white),
            onChanged: (view) => setState(() => _currentView = view!),
            items: ScheduleView.values
                .map((view) => DropdownMenuItem(value: view, child: Text(view.toString().split('.').last)))
                .toList(),
          ),
        ],
      ),
      body: schedulesAsync.when(
        data: (schedules) =>
            schedules.isEmpty ? const Center(child: Text('No schedules')) : _buildView(context, ref, schedules),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Card(
          margin: const EdgeInsets.all(16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Text('Error: $e', style: TextStyle(color: Theme.of(context).colorScheme.error)),
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.pushNamed(context, '/schedules/add'),
        child: const Icon(Icons.add),
      ),
    );
  }

  Widget _buildView(BuildContext context, WidgetRef ref, List<Schedule> schedules) {
    switch (_currentView) {
      case ScheduleView.list:
        return ListView.builder(
          itemCount: schedules.length,
          itemBuilder: (context, index) => _buildScheduleRow(context, ref, schedules[index]),
        );
      case ScheduleView.day:
        return _buildDayView(context, ref, schedules);
      case ScheduleView.week:
        return _buildWeekView(context, ref, schedules);
      case ScheduleView.month:
        return _buildMonthView(context, ref, schedules);
    }
  }

  Future<String> _getDoseStatus(Schedule schedule, WidgetRef ref, [String? day]) async {
    final now = DateTime.now();
    final targetDay = day != null ? _weekdayToIndex(day) : now.weekday;
    final isScheduled = schedule.frequency == 'Daily' || schedule.days.contains(day ?? _weekdayToString(now.weekday));
    if (!isScheduled) return 'Upcoming';
    final targetDate = _getDateForDay(now, targetDay);
    final scheduleTime = DateTime(
      targetDate.year,
      targetDate.month,
      targetDate.day,
      schedule.time.hour,
      schedule.time.minute,
    );
    final gracePeriod = const Duration(hours: 1); // TODO: Make editable in settings
    if (scheduleTime.add(gracePeriod).isAfter(now)) return 'Upcoming';
    final history = await ref.read(driftServiceProvider).getDoseHistory(schedule.doseId ?? -1);
    if (history.any((h) => h.takenAt.isAfter(scheduleTime.subtract(const Duration(minutes: 1))))) {
      return 'Taken';
    }
    // Placeholder: Check for Postponed/Cancelled
    return 'Missed';
  }

  DateTime _getDateForDay(DateTime now, int targetDay) {
    final currentDay = now.weekday;
    final daysDiff = (targetDay - currentDay + 7) % 7;
    return now.add(Duration(days: daysDiff));
  }

  int _weekdayToIndex(String day) {
    const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    return days.indexOf(day) + 1;
  }

  Widget _buildScheduleRow(BuildContext context, WidgetRef ref, Schedule schedule) {
    return FutureBuilder<String>(
      future: _getDoseStatus(schedule, ref),
      builder: (context, snapshot) {
        final status = snapshot.data ?? 'Upcoming';
        final statusColor = {
          'Taken': Colors.green,
          'Missed': Colors.red,
          'Postponed': Colors.orange,
          'Cancelled': Colors.red,
          'Upcoming': Colors.blue,
        }[status]!;
        return Card(
          margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 16),
          child: ListTile(
            title: Text(schedule.medicationName),
            subtitle: Text(
              'Time: ${DateFormat.jm().format(schedule.time)}, Days: ${schedule.days.join(', ')}\nStatus: $status',
              style: TextStyle(color: statusColor),
            ),
            trailing: IconButton(
              icon: const Icon(Icons.edit),
              onPressed: () => Navigator.pushNamed(context, '/schedules/edit', arguments: schedule.id),
            ),
          ),
        );
      },
    );
  }

  Widget _buildDayView(BuildContext context, WidgetRef ref, List<Schedule> schedules) {
    final today = DateTime.now();
    final todaySchedules = schedules.where((s) => s.days.contains(_weekdayToString(today.weekday))).toList();
    return SingleChildScrollView(
      child: DataTable(
        columns: const [
          DataColumn(label: Text('Medication')),
          DataColumn(label: Text('Time')),
          DataColumn(label: Text('Status')),
        ],
        rows: todaySchedules.map((schedule) {
          return DataRow(
            cells: [
              DataCell(Text(schedule.medicationName)),
              DataCell(Text(DateFormat.jm().format(schedule.time))),
              DataCell(
                FutureBuilder<String>(
                  future: _getDoseStatus(schedule, ref),
                  builder: (context, snapshot) {
                    final status = snapshot.data ?? 'Upcoming';
                    final statusColor = {
                      'Taken': Colors.green,
                      'Missed': Colors.red,
                      'Postponed': Colors.orange,
                      'Cancelled': Colors.red,
                      'Upcoming': Colors.blue,
                    }[status]!;
                    return Text(status, style: TextStyle(color: statusColor));
                  },
                ),
              ),
            ],
          );
        }).toList(),
      ),
    );
  }

  Widget _buildWeekView(BuildContext context, WidgetRef ref, List<Schedule> schedules) {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: DataTable(
        columns: [
          const DataColumn(label: Text('Medication')),
          ...['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day) => DataColumn(label: Text(day))),
        ],
        rows: schedules.map((schedule) {
          return DataRow(
            cells: [
              DataCell(Text(schedule.medicationName)),
              ...['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map(
                (day) => DataCell(
                  schedule.days.contains(day)
                      ? FutureBuilder<String>(
                          future: _getDoseStatus(schedule, ref),
                          builder: (context, snapshot) {
                            final status = snapshot.data ?? 'Upcoming';
                            final statusColor = {
                              'Taken': Colors.green,
                              'Missed': Colors.red,
                              'Postponed': Colors.orange,
                              'Cancelled': Colors.red,
                              'Upcoming': Colors.blue,
                            }[status]!;
                            return Text(DateFormat.jm().format(schedule.time), style: TextStyle(color: statusColor));
                          },
                        )
                      : const Text('-'),
                ),
              ),
            ],
          );
        }).toList(),
      ),
    );
  }

  Widget _buildMonthView(BuildContext context, WidgetRef ref, List<Schedule> schedules) {
    return const Center(child: Text('Month view: TBD')); // Placeholder
  }

  String _weekdayToString(int weekday) {
    const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    return days[weekday - 1];
  }
}

// --- FILE BREAK ---

// File: lib/features/schedule/screens/schedule_screen.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:flutter/services.dart';
import 'package:logging/logging.dart';
import '../../../common/mixins/controller_mixin.dart';
import '../../../data/database.dart';
import '../../../services/drift_service.dart';
import '../../../services/notification_service.dart';
import '../constants/schedule_form_constants.dart';
import '../widgets/schedule_form_card.dart';
import '../widgets/schedule_form_field.dart';

class ScheduleScreen extends ConsumerStatefulWidget {
  final Medication medication;

  const ScheduleScreen({super.key, required this.medication});

  @override
  ConsumerState<ScheduleScreen> createState() => _ScheduleScreenState();
}

class _ScheduleScreenState extends ConsumerState<ScheduleScreen> with ControllerMixin {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final Logger _logger = Logger('ScheduleScreen');
  String _frequency = ScheduleFormConstants.defaultFrequency;
  List<String> _days = [];
  TimeOfDay _selectedTime = TimeOfDay.now();
  Dose? _selectedDose;

  @override
  void initState() {
    super.initState();
    setupListeners([_nameController], () => setState(() {}));
  }

  @override
  void dispose() {
    disposeControllers([_nameController]);
    super.dispose();
  }

  void _updateFrequency(String? value) {
    if (value != null) {
      setState(() {
        _frequency = value;
        _days = value == ScheduleFormConstants.dailyFrequency ? ScheduleFormConstants.daysOfWeek : [];
      });
    }
  }

  void _toggleDay(String day, bool selected) {
    setState(() {
      if (selected) _days.add(day);
      else _days.remove(day);
    });
  }

  void _updateTime(TimeOfDay? time) {
    if (time != null) setState(() => _selectedTime = time);
  }

  void _updateDose(Dose? dose) {
    if (dose != null) {
      setState(() {
        _selectedDose = dose;
        _nameController.text = dose.name ?? widget.medication.name;
      });
    }
  }

  Future<void> _saveSchedule() async {
    if (!_formKey.currentState!.validate() || _selectedDose == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a dose')),
      );
      return;
    }
    if (_frequency == ScheduleFormConstants.weeklyFrequency && _days.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text(ScheduleFormConstants.noDaysSelectedMessage)),
      );
      return;
    }

    final now = tz.TZDateTime.now(tz.local);
    var scheduleTime = tz.TZDateTime(
      tz.local,
      now.year,
      now.month,
      now.day,
      _selectedTime.hour,
      _selectedTime.minute,
    );
    if (scheduleTime.isBefore(now)) {
      scheduleTime = scheduleTime.add(const Duration(days: 1));
    }

    final schedule = SchedulesCompanion(
      frequency: drift.Value(_frequency),
      days: drift.Value(_frequency == ScheduleFormConstants.dailyFrequency ? ScheduleFormConstants.daysOfWeek : _days),
      time: drift.Value(DateTime(1970, 1, 1, _selectedTime.hour, _selectedTime.minute)),
      name: drift.Value(_nameController.text),
      doseId: drift.Value(_selectedDose!.id),
    );

    try {
      final scheduleId = await ref.read(driftServiceProvider).addSchedule(schedule);
      final notificationService = NotificationService();
      await notificationService.scheduleNotification(
        'schedule_$scheduleId',
        ScheduleFormConstants.notificationTitle(widget.medication.name),
        ScheduleFormConstants.notificationBodyWithDose(_selectedDose!.amount, _selectedDose!.unit, _nameController.text),
        scheduleTime,
        days: _frequency == ScheduleFormConstants.dailyFrequency ? ScheduleFormConstants.daysOfWeek : _days,
      );
      await notificationService.logPendingNotifications();
      ref.invalidate(dosesProvider(widget.medication.id));
      ref.invalidate(schedulesProvider(widget.medication.id));
      ref.invalidate(medicationsProvider);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text(ScheduleFormConstants.scheduleSavedMessage)),
      );
      Navigator.pop(context);
    } catch (e) {
      _logger.severe('Error saving schedule: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            e is PlatformException && e.code == 'permissions_denied'
                ? 'Please grant alarm and notification permissions'
                : ScheduleFormConstants.errorSavingMessage(e),
          ),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(ScheduleFormConstants.screenTitle(widget.medication.name)),
        flexibleSpace: Container(decoration: ScheduleFormConstants.appBarGradient(context)),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: ScheduleFormConstants.formPadding,
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ScheduleFormCard(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(ScheduleFormConstants.doseLabel, style: ScheduleFormConstants.sectionTitleStyle(context)),
                      const SizedBox(height: ScheduleFormConstants.innerSpacing),
                      FutureBuilder<List<Dose>>(
                        future: ref.read(driftServiceProvider).getDoses(widget.medication.id),
                        builder: (context, snapshot) {
                          if (snapshot.connectionState == ConnectionState.waiting) {
                            return const CircularProgressIndicator();
                          }
                          final doses = snapshot.data ?? [];
                          return DropdownButtonFormField<Dose>(
                            decoration: ScheduleFormConstants.dropdownDecoration('Select Dose (Required)'),
                            value: _selectedDose,
                            items: doses.map((dose) => DropdownMenuItem(
                              value: dose,
                              child: Text(ScheduleFormConstants.doseDisplay(dose)),
                            )).toList(),
                            onChanged: _updateDose,
                            validator: (value) => value == null ? 'Dose required' : null,
                            style: Theme.of(context).textTheme.bodyLarge,
                            dropdownColor: Colors.white,
                            borderRadius: BorderRadius.circular(12),
                          );
                        },
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: ScheduleFormConstants.fieldSpacing),
                ScheduleFormCard(
                  child: TextFormField(
                    controller: _nameController,
                    decoration: ScheduleFormConstants.textFieldDecoration(ScheduleFormConstants.nameLabel, ScheduleFormConstants.nameHelper),
                    validator: (value) => value!.isEmpty ? ScheduleFormConstants.nameRequiredMessage : null,
                  ),
                ),
                const SizedBox(height: ScheduleFormConstants.fieldSpacing),
                ScheduleFormCard(
                  child: DropdownButtonFormField<String>(
                    decoration: ScheduleFormConstants.dropdownDecoration(ScheduleFormConstants.frequencyLabel),
                    value: _frequency,
                    items: ScheduleFormConstants.frequencies
                        .map((item) => DropdownMenuItem(value: item, child: Text(item)))
                        .toList(),
                    onChanged: _updateFrequency,
                    validator: (value) => value == null ? ScheduleFormConstants.frequencyRequiredMessage : null,
                    style: Theme.of(context).textTheme.bodyLarge,
                    dropdownColor: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                if (_frequency == ScheduleFormConstants.weeklyFrequency) ...[
                  const SizedBox(height: ScheduleFormConstants.fieldSpacing),
                  ScheduleFormCard(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(ScheduleFormConstants.daysLabel, style: ScheduleFormConstants.sectionTitleStyle(context)),
                        const SizedBox(height: ScheduleFormConstants.innerSpacing),
                        Wrap(
                          spacing: 8,
                          children: ScheduleFormConstants.daysOfWeek.map((day) {
                            final isSelected = _days.contains(day);
                            return ChoiceChip(
                              label: Text(day),
                              selected: isSelected,
                              onSelected: (selected) => _toggleDay(day, selected),
                            );
                          }).toList(),
                        ),
                      ],
                    ),
                  ),
                ],
                const SizedBox(height: ScheduleFormConstants.fieldSpacing),
                ScheduleFormCard(
                  child: ListTile(
                    title: Text(
                      ScheduleFormConstants.timeLabel(_selectedTime),
                      style: Theme.of(context).textTheme.bodyLarge,
                    ),
                    trailing: const Icon(Icons.edit, color: Colors.grey),
                    contentPadding: ScheduleFormConstants.cardContentPadding,
                    onTap: () async => _updateTime(await showTimePicker(context: context, initialTime: _selectedTime)),
                  ),
                ),
                const SizedBox(height: ScheduleFormConstants.buttonSpacing),
                ElevatedButton(
                  onPressed: _saveSchedule,
                  style: ScheduleFormConstants.buttonStyle,
                  child: Text(
                    ScheduleFormConstants.saveButton,
                    style: ScheduleFormConstants.buttonTextStyle(context),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/schedule/widgets/schedule_form_card.dart
import 'package:flutter/material.dart';
import '../constants/schedule_form_constants.dart';

class ScheduleFormCard extends StatelessWidget {
  final Widget child;

  const ScheduleFormCard({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: ScheduleFormConstants.cardElevation,
      shape: ScheduleFormConstants.cardShape,
      child: Padding(
        padding: ScheduleFormConstants.cardPadding,
        child: child,
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/features/schedule/widgets/schedule_form_field.dart
import 'package:flutter/material.dart';
import '../constants/schedule_form_constants.dart';
import 'schedule_form_card.dart';

class ScheduleFormField extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final String? helperText;
  final String? Function(String?)? validator;

  const ScheduleFormField({
    super.key,
    required this.controller,
    required this.label,
    this.helperText,
    this.validator,
  });

  @override
  Widget build(BuildContext context) {
    return ScheduleFormCard(
      child: TextFormField(
        controller: controller,
        decoration: ScheduleFormConstants.textFieldDecoration(label, helperText),
        validator: validator,
      ),
    );
  }
}

// --- FILE BREAK ---

// File: lib/services/dose_service.dart
import 'package:drift/drift.dart' as drift;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logging/logging.dart';
import 'package:timezone/timezone.dart' as tz;
import '../data/database.dart';
import 'drift_service.dart'; // Added import
import 'notification_service.dart';

final doseServiceProvider = Provider<DoseService>((ref) => DoseService(ref));

class DoseService {
  final Ref _ref;
  final Logger _logger = Logger('DoseService');

  DoseService(this._ref);

  AppDatabase get _db => _ref.read(driftServiceProvider);

  Future<void> takeDose(int medicationId, int doseId, double amount) async {
    await _db.transaction(() async {
      _logger.info('Taking dose: medId=$medicationId, doseId=$doseId, amount=$amount');
      final med = await (_db.select(_db.medications)..where((m) => m.id.equals(medicationId)))
          .getSingleOrNull();
      if (med == null || med.stockQuantity < amount) {
        _logger.warning('Insufficient stock for medId=$medicationId, required=$amount, available=${med?.stockQuantity}');
        throw Exception('Insufficient stock');
      }
      await _db.updateMedicationStock(medicationId, med.stockQuantity - amount);
      await _db.addDoseHistory(DoseHistoryCompanion(
        doseId: drift.Value(doseId),
        takenAt: drift.Value(DateTime.now()),
      ));
      final schedules = await _db.getSchedules(medicationId);
      final today = _weekdayToString(DateTime.now().weekday);
      for (final schedule in schedules) {
        if (schedule.doseId == doseId && schedule.frequency != 'Daily' && schedule.days.contains(today)) {
          final updatedDays = schedule.days.where((day) => day != today).toList();
          _logger.info('Updating schedule ${schedule.id} to remove $today: $updatedDays');
          await _db.updateSchedule(
              schedule.id, SchedulesCompanion(days: drift.Value(updatedDays)));
        }
      }
    });
  }

  Future<void> snoozeDose(int scheduleId) async {
    _logger.info('Snoozing dose: scheduleId=$scheduleId');
    final schedule = await (_db.select(_db.schedules)..where((s) => s.id.equals(scheduleId)))
        .getSingleOrNull();
    if (schedule != null) {
      final now = tz.TZDateTime.now(tz.local);
      final newTime = now.add(const Duration(hours: 1));
      await _db.updateSchedule(
        scheduleId,
        SchedulesCompanion(
          time: drift.Value(DateTime(now.year, now.month, now.day, newTime.hour, newTime.minute)),
        ),
      );
      if (schedule.notificationId != null) {
        await _ref.read(notificationServiceProvider).scheduleNotification(
          id: schedule.notificationId!,
          title: 'Snoozed Dose: ${schedule.name}',
          body: 'Time to take your dose!',
          scheduledTime: DateTime(now.year, now.month, now.day, newTime.hour, newTime.minute),
          days: schedule.days.isEmpty ? ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] : schedule.days,
        );
      }
    }
  }

  Future<void> cancelDose(int scheduleId) async {
    _logger.info('Canceling dose: scheduleId=$scheduleId');
    final schedule = await (_db.select(_db.schedules)..where((s) => s.id.equals(scheduleId)))
        .getSingleOrNull();
    if (schedule != null) {
      final today = _weekdayToString(DateTime.now().weekday);
      final updatedDays = schedule.days.where((day) => day != today).toList();
      await _db.updateSchedule(
        scheduleId,
        SchedulesCompanion(days: drift.Value(updatedDays)),
      );
    }
  }

  Future<bool> isDoseAvailableToday(Schedule schedule) async {
    final today = DateTime.now();
    final isToday = schedule.frequency == 'Daily' ||
        schedule.days.contains(_weekdayToString(today.weekday));
    final time = schedule.time;
    final isBefore = today.hour < time.hour || (today.hour == time.hour && today.minute <= time.minute);
    _logger.info('Dose availability for schedule ${schedule.id}: $isToday && $isBefore');
    return isToday && isBefore;
  }

  String _weekdayToString(int weekday) {
    const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    return days[weekday - 1];
  }
}

// --- FILE BREAK ---

// File: lib/services/drift_service.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/database.dart';

final driftServiceProvider = Provider<AppDatabase>((ref) => AppDatabase());

final medicationsProvider = FutureProvider<List<Medication>>((ref) async {
  return ref.watch(driftServiceProvider).getMedications();
});

final allDosesProvider = FutureProvider<List<Dose>>((ref) async {
  return ref.watch(driftServiceProvider).getAllDoses();
});

final schedulesProvider = FutureProvider<List<Schedule>>((ref) async {
  return ref.watch(driftServiceProvider).getAllSchedules();
});

// --- FILE BREAK ---

// File: lib/services/notification_service.dart
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logging/logging.dart';
import 'package:timezone/data/latest.dart' as tz;
import 'package:timezone/timezone.dart' as tz;

final notificationServiceProvider = Provider<NotificationService>((ref) {
  final service = NotificationService();
  ref.onDispose(() => service.cancelAllNotifications());
  return service..initialize();
});

class NotificationService {
  final FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();
  final Logger _logger = Logger('NotificationService');
  late tz.Location _local;

  Future<void> initialize() async {
    _logger.info('Initializing notification service');
    tz.initializeTimeZones();
    try {
      _local = tz.getLocation('Australia/Sydney'); // Set to AEST
      _logger.info('Timezone initialized: ${_local.name}');
    } catch (e) {
      _logger.severe('Failed to initialize timezone: $e');
      rethrow;
    }
    const android = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iOS = DarwinInitializationSettings();
    const settings = InitializationSettings(android: android, iOS: iOS);
    await _flutterLocalNotificationsPlugin.initialize(settings);
    final androidPlugin = _flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>();
    await androidPlugin?.requestNotificationsPermission();
  }

  Future<void> scheduleNotification({
    required String id,
    required String title,
    required String body,
    required DateTime scheduledTime,
    required List<String> days,
  }) async {
    try {
      final now = tz.TZDateTime.now(_local);
      for (final day in days) {
        final dayIndex = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].indexOf(day);
        if (dayIndex == -1) {
          _logger.warning('Invalid day: $day');
          continue;
        }
        final nextDay = now.add(Duration(days: (dayIndex - now.weekday + 7) % 7));
        final scheduled = tz.TZDateTime(
          _local,
          nextDay.year,
          nextDay.month,
          nextDay.day,
          scheduledTime.hour,
          scheduledTime.minute,
        );
        _logger.fine('Scheduling notification: ID=$id, Title=$title, Time=$scheduled, Days=$days');
        await _flutterLocalNotificationsPlugin.zonedSchedule(
          id.hashCode,
          title,
          body,
          scheduled,
          const NotificationDetails(
            android: AndroidNotificationDetails(
              'medminder',
              'MedMinder Notifications',
              importance: Importance.max,
              priority: Priority.high,
            ),
            iOS: DarwinNotificationDetails(),
          ),
          androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
          matchDateTimeComponents: DateTimeComponents.dayOfWeekAndTime,
        );
        _logger.info('Successfully scheduled notification: ID=$id, Title=$title, Time=$scheduled, Days=$days');
      }
    } catch (e) {
      _logger.severe('Failed to schedule notification: ID=$id, Error=$e');
      rethrow;
    }
  }

  Future<void> cancelNotification(String id) async {
    await _flutterLocalNotificationsPlugin.cancel(id.hashCode);
    _logger.info('Cancelled notification: $id');
  }

  Future<void> cancelAllNotifications() async {
    await _flutterLocalNotificationsPlugin.cancelAll();
    _logger.info('Cancelled all notifications');
  }
}

// --- FILE BREAK ---

// File: lib/widgets/dialog_input.dart
import 'package:flutter/material.dart';

class DialogInput extends StatelessWidget {
  final String title;
  final String hint;
  final String helpText;
  final TextEditingController controller;
  final VoidCallback onConfirm;

  const DialogInput({
    super.key,
    required this.title,
    required this.hint,
    required this.helpText,
    required this.controller,
    required this.onConfirm,
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(title),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: controller,
            decoration: InputDecoration(hintText: hint),
            keyboardType: TextInputType.number,
          ),
          const SizedBox(height: 8),
          Text(helpText, style: const TextStyle(fontSize: 12, color: Colors.grey)),
        ],
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
        ElevatedButton(onPressed: onConfirm, child: const Text('Confirm')),
      ],
    );
  }
}

// --- FILE BREAK ---

// File: lib/widgets/form_widgets.dart
// lib/widgets/form_widgets.dart
import 'package:flutter/material.dart';

class FormWidgets {
  static Future<String?> showInputDialog({
    required BuildContext context,
    required String title,
    required String initialValue,
    required String label,
    String? helperText,
    TextInputType? keyboardType,
    String? Function(String?)? validator,
    List<String>? dropdownItems,
    String? dropdownValue,
    ValueChanged<String?>? onDropdownChanged,
  }) async {
    final controller = TextEditingController(text: initialValue);
    String? dropdownCurrentValue = dropdownValue;
    String? errorText;

    return await showDialog<String?>(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              backgroundColor: Colors.white,
              contentPadding: const EdgeInsets.all(24),
              insetPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 24),
              content: ConstrainedBox(
                constraints: BoxConstraints(
                  minWidth: 280,
                  maxWidth: MediaQuery.of(context).size.width * 0.9,
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                        color: Theme.of(context).primaryColor,
                      ),
                    ),
                    const SizedBox(height: 16),
                    if (dropdownItems != null && dropdownItems.isNotEmpty)
                      Row(
                        children: [
                          Expanded(
                            child: TextFormField(
                              controller: controller,
                              decoration: InputDecoration(
                                labelText: label,
                                helperText: helperText,
                                errorText: errorText,
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                filled: true,
                                fillColor: Colors.grey[100],
                                contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                              ),
                              keyboardType: keyboardType ?? TextInputType.text,
                              textCapitalization: TextCapitalization.words,
                              autofocus: true,
                              onChanged: (value) {
                                setState(() {
                                  errorText = validator?.call(value);
                                });
                              },
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: DropdownButtonFormField<String>(
                              decoration: InputDecoration(
                                labelText: 'Unit',
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                filled: true,
                                fillColor: Colors.grey[100],
                                contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                              ),
                              value: dropdownCurrentValue,
                              items: dropdownItems
                                  .map((item) => DropdownMenuItem(value: item, child: Text(item)))
                                  .toList(),
                              onChanged: (value) {
                                setState(() {
                                  dropdownCurrentValue = value;
                                  onDropdownChanged?.call(value);
                                });
                              },
                              validator: (value) => value == null || value.isEmpty ? 'Required' : null,
                            ),
                          ),
                        ],
                      )
                    else
                      TextFormField(
                        controller: controller,
                        decoration: InputDecoration(
                          labelText: label,
                          helperText: helperText,
                          errorText: errorText,
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                          filled: true,
                          fillColor: Colors.grey[100],
                          contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                        ),
                        keyboardType: keyboardType ?? TextInputType.text,
                        textCapitalization: TextCapitalization.words,
                        autofocus: true,
                        onChanged: (value) {
                          setState(() {
                            errorText = validator?.call(value);
                          });
                        },
                      ),
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        TextButton(
                          onPressed: () => Navigator.pop(context),
                          child: Text(
                            'Cancel',
                            style: TextStyle(color: Theme.of(context).primaryColor),
                          ),
                        ),
                        ElevatedButton(
                          onPressed: () {
                            if (dropdownItems != null) {
                              if (controller.text.isNotEmpty && dropdownCurrentValue != null) {
                                Navigator.pop(context, controller.text);
                              } else {
                                setState(() {
                                  errorText = controller.text.isEmpty ? '$label is required' : 'Please select a unit';
                                });
                              }
                            } else {
                              final textError = validator?.call(controller.text);
                              setState(() {
                                errorText = textError;
                              });
                              if (textError == null) {
                                Navigator.pop(context, controller.text);
                              }
                            }
                          },
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Theme.of(context).primaryColor,
                            foregroundColor: Colors.white,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          ),
                          child: const Text('Confirm'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }
}

// --- FILE BREAK ---

// File: lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'common/theme/app_theme.dart';
import 'features/home/home_screen.dart';
import 'features/medication/screens/medication_info_screen.dart';
import 'features/medication/screens/medication_add_screen.dart';
import 'features/medication/screens/medication_overview_screen.dart';
import 'features/dose/screens/dose_info_screen.dart';
import 'features/dose/screens/dose_add_screen.dart';
import 'features/dose/screens/dose_edit_screen.dart';
import 'features/schedule/screens/schedule_info_screen.dart';
import 'features/schedule/screens/schedule_add_screen.dart';
import 'features/schedule/screens/schedule_edit_screen.dart';
import 'services/notification_service.dart';

final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await NotificationService().initialize();
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MedMinder',
      theme: appTheme,
      navigatorKey: navigatorKey,
      home: const MainScaffold(),
      routes: {
        '/medications/info': (context) => const MedicationsInfoScreen(),
        '/medications/add': (context) => const MedicationsAddScreen(),
        '/medications/edit': (context) =>
            MedicationOverviewScreen(medicationId: ModalRoute.of(context)!.settings.arguments as int),
        '/doses/info': (context) => const DosesInfoScreen(),
        '/doses/add': (context) => const DosesAddScreen(),
        '/doses/edit': (context) => DosesEditScreen(doseId: ModalRoute.of(context)!.settings.arguments as int),
        '/schedules/info': (context) => const SchedulesInfoScreen(),
        '/schedules/add': (context) => const SchedulesAddScreen(),
        '/schedules/edit': (context) =>
            SchedulesEditScreen(scheduleId: ModalRoute.of(context)!.settings.arguments as int),
      },
    );
  }
}

class MainScaffold extends StatefulWidget {
  const MainScaffold({super.key});

  @override
  State<MainScaffold> createState() => _MainScaffoldState();
}

class _MainScaffoldState extends State<MainScaffold> {
  int _selectedIndex = 0;

  static const List<Widget> _screens = [HomeScreen(), MedicationsInfoScreen(), SchedulesInfoScreen()];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _screens[_selectedIndex],
      bottomNavigationBar: BottomNavigationBar(
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
          BottomNavigationBarItem(icon: Icon(Icons.medication), label: 'Medications'),
          BottomNavigationBarItem(icon: Icon(Icons.calendar_today), label: 'Schedules'),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: Theme.of(context).primaryColor,
        onTap: _onItemTapped,
      ),
    );
  }
}

// --- FILE BREAK ---

// File: android/app/src/debug/AndroidManifest.xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>


// --- FILE BREAK ---

// File: android/app/src/main/AndroidManifest.xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.VIBRATE"/>
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM"/>
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <application
        android:label="medminder2"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher"
        android:enableOnBackInvokedCallback="true">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">

            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

// --- FILE BREAK ---

// File: android/app/src/profile/AndroidManifest.xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>


// --- FILE BREAK ---

// File: android/app/build.gradle.kts
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.kinemspa.medminder2"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = "27.0.12077973"

    compileOptions {
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.kinemspa.medminder2"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
    implementation ("androidx.core:core:1.13.1")
}

// --- FILE BREAK ---

// File: android/gradle/wrapper/gradle-wrapper.properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-all.zip


// --- FILE BREAK ---

// File: android/build.gradle.kts
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}


// --- FILE BREAK ---

// File: android/settings.gradle.kts
pluginManagement {
    val flutterSdkPath = run {
        val properties = java.util.Properties()
        file("local.properties").inputStream().use { properties.load(it) }
        val flutterSdkPath = properties.getProperty("flutter.sdk")
        require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
        flutterSdkPath
    }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.7.3" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")


// --- FILE BREAK ---

// File: ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.

// --- FILE BREAK ---

// File: linux/flutter/ephemeral/.plugin_symlinks/flutter_local_notifications_linux/README.md
# Flutter Local Notifications Linux plugin

The Linux implementation of [`flutter_local_notifications`](https://pub.dev/packages/flutter_local_notifications).

## Usage

This package is already included as part of the `flutter_local_notifications` package dependency, and will
be included when using `flutter_local_notifications` as normal.


// --- FILE BREAK ---

// File: linux/flutter/ephemeral/.plugin_symlinks/path_provider_linux/example/README.md
# Platform Implementation Test App

This is a test app for manual testing and automated integration testing
of this platform implementation. It is not intended to demonstrate actual use of
this package, since the intent is that plugin clients use the app-facing
package.

Unless you are making changes to this implementation package, this example is
very unlikely to be relevant.


// --- FILE BREAK ---

// File: linux/flutter/ephemeral/.plugin_symlinks/path_provider_linux/README.md
# path\_provider\_linux

The linux implementation of [`path_provider`][1].

## Usage

This package is [endorsed][2], which means you can simply use `path_provider`
normally. This package will be automatically included in your app when you do,
so you do not need to add it to your `pubspec.yaml`.

However, if you `import` this package to use any of its APIs directly, you
should add it to your `pubspec.yaml` as usual.

[1]: https://pub.dev/packages/path_provider
[2]: https://flutter.dev/docs/development/packages-and-plugins/developing-packages#endorsed-federated-plugin


// --- FILE BREAK ---

// File: linux/flutter/ephemeral/.plugin_symlinks/sqlite3_flutter_libs/example/README.md
We only have this example because otherwise `flutter packages get` in `sqlite3_flutter_libs` fails.

// --- FILE BREAK ---

// File: linux/flutter/ephemeral/.plugin_symlinks/sqlite3_flutter_libs/README.md
# sqlite3_flutter_libs

This package intentionally contains no Dart code. Flutter apps depending on this package will
contain native `sqlite3` libraries on Android, iOS, macOS, Linux and Windows.

For more details on how to actually use this package in a Flutter app, see
[sqlite3](https://pub.dev/packages/sqlite3).

The sqlite3 version compiled with this package uses the
[recommended compile-time options](https://www.sqlite.org/compile.html#recommended_compile_time_options).
Additionally, it ships the `fts5` module by default (the `json1` module is part
of the default build in recent sqlite3 versions).
No other modules are included in these builds.

## Notes on Android

### Included platforms

Note that, on Android, this library will bundle sqlite3 for all of the following platforms:

- `arm64-v8a`
- `armeabi-v7a`
- `x86`
- `x86_64`

If you don't intend to release to 32-bit `x86` devices, you'll need to apply a
[filter](https://developer.android.com/ndk/guides/abis#gc) in your `build.gradle`:

For Kotlin buildscripts (`.gradle.kts`):

```Kotlin
android {
    defaultConfig {
        ndk {
            abiFilters += setOf("armeabi-v7a", "arm64-v8a", "x86_64")
        }
    }
}
```

Or for Groovy (`.gradle`):

```gradle
android {
    defaultConfig {
        ndk {
            abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86_64'
        }
    }
}
```

### Problems on Android 6

There appears to be a problem when loading native libraries on Android 6 (see [this issue](https://github.com/simolus3/moor/issues/895#issuecomment-720195005)).
If you're seeing those crashes, you could try setting `android.bundle.enableUncompressedNativeLibs=false` in your `gradle.properties`
file. Be aware that this increases the size of your application when installed.

Alternatively, you can use the `applyWorkaroundToOpenSqlite3OnOldAndroidVersions` method from this library.
It will try to open `sqlite3` in Java, which seems to work more reliably. After sqlite3 has been loaded from Java,
we can open it in Dart too.
The method should be called before using `sqlite3` (either directly or indirectly through say a `NativeDatabase` from `package:drift`).

As `applyWorkaroundToOpenSqlite3OnOldAndroidVersions` uses platform channels, there may be issues when using it on a background isolate.
We recommend awaiting it in the main isolate, _before_ spawning a background isolate that might use the database.

### Providing a temporary path

If you have complex queries failing with a `SQLITE_IOERR_GETTEMPPATH 6410` error, you could try to explicitly set the
temporary path used by sqlite3. [This comment](https://github.com/simolus3/moor/issues/876#issuecomment-710013503) contains a snippet
to do just that.


// --- FILE BREAK ---

// File: README.md
# MedMinder2

## Project Overview
**MedMinder2** is a Flutter-based medication management app designed to help users track medications, manage doses, and schedule reminders. Built with **Flutter 3.32.1** and **Dart 3.8.1**, it runs on Android (API 34, Pixel 6 emulator) under Windows 11. The app uses **Riverpod** for state management, **Drift** for local SQLite storage (`medminder.sqlite`), **get_storage** for lightweight persistence, and **flutter_local_notifications (^19.2.1)** for reminders. It supports adding, editing, and deleting medications, doses, and schedules, with a clean Material Design UI and robust data validation.

## Importance of `medication_matrix.dart`
The `common/medication_matrix.dart` file is the cornerstone of MedMinder2â€™s logic, ensuring consistency and reliability:
- **Medication Types**: Defines supported forms (e.g., `Tablet`, `Injection`, `Capsule`) and maps them to UI dropdowns.
- **Unit Management**: Specifies valid units for concentration (e.g., `mg`, `mcg`, `mg/mL`) and administration (e.g., `mL`, `IU`), dynamically sourced by medication type.
- **Calculations and Conversions**: Provides `convertUnit` for unit conversions (e.g., mg to mcg) and `calculateAdministrationDose` for precise dose calculations (e.g., mL for injections).
- **Validation**: Enforces input ranges (0.01â€“999) via `isValidValue`, preventing invalid entries.
  This file drives UI logic, form validations, and calculations across screens, ensuring accurate and safe medication management.

## Core Features
1. **Medication Management**:
    - Add, edit, delete medications with name, concentration, unit, quantity, and type (e.g., Tablet, Injection).
    - Stored in Drift SQLite database (`medminder.sqlite`).
    - UI: `features/medication/screens/medication_screen.dart` with dynamic summary and validation.
2. **Dose Management**:
    - Create, edit, delete doses linked to medications, supporting tablet counts or concentration-based inputs (e.g., mL for injections).
    - UI: `features/dose/screens/dose_form.dart` with dialog-based inputs and real-time summary updates.
3. **Scheduling**:
    - Set daily or weekly dose schedules with customizable days and times.
    - Partial notification integration via `flutter_local_notifications`.
    - UI: `features/schedule/screens/schedule_screen.dart` with frequency, day selection, and optional dose assignment.
4. **History Tracking**:
    - View dose history across medications.
    - UI: `features/history/screens/history_screen.dart` with medication and schedule details.
5. **Home Screen**:
    - Lists medications via `features/home/widgets/medication_card.dart`, showing stock and schedules.
    - Navigation to Medication, Dose, Schedule, and History screens.
6. **UI and Theming**:
    - Material Design with gradient app bars, full-width cards, and dialog inputs.
    - Theming in `common/theme/app_theme.dart` (primary color: teal).

## Planned Functionality
- **Notifications**: Fully implement `NotificationService` for dose reminders, ensuring exact alarms and multi-day scheduling.
- **Reconstitution Calculator** for Injection and other liquid meds.
- **Expanded Medication Types**: Support additional forms (e.g., `Drops`, `Inhaler`) from `medication_matrix.dart`.
- **Unit Tests**: Add tests for core operations (e.g., Schedule creation, Dose deletion) using the `test` package.

## Current Status
- **Date**: June 6, 2025, 7:00 PM AEST
- **Platform**: Android (API 34, Pixel 6 emulator)
- **Environment**: Windows 11, Flutter 3.32.1 (stable), Dart 3.8.1
- **Project Directory**: `C:\Users\kook1\AndroidStudioProjects\Projects\medminder2`
- **App Behavior**:
    - **Home Screen**: Displays medications, navigates to other screens.
    - **Medication Screen**: Form with dropdown, validated inputs, no overflow, saves to database.
    - **Dose Screen**: Manages doses with tablet/injection support, drop size calibration.
    - **Schedule Screen**: Creates schedules with daily/weekly options, partial notification support.
    - **History Screen**: Shows dose history with medication details.
    - **Debug Logging**: Enabled for database and UI operations.
- **Resolved Issues**:
    - Android v1 embedding upgraded to v2.
    - Desugaring enabled (`isCoreLibraryDesugaringEnabled`, `multiDexEnabled`).
    - Backup path corrected to `C:\Users\kook1\AndroidStudioProjects\Projects\medminder_backup`.
    - Drift `Column` conflict resolved with `as drift` prefix.
    - `CardTheme` mismatch fixed with `CardThemeData`.
    - MedicationScreen overflow (87 pixels) fixed with `SingleChildScrollView`.
- **Recent Updates**:
    - Refactored `MedicationScreen` and `DoseForm` with modular widgets, constants, and optimized code.
    - Refactored `ScheduleScreen` with `ScheduleFormField`, `ScheduleFormCard`, and constants.
    - Proposed folder structure cleanup for feature-based organization.
- Update: Fixed doseTextName typo in SchedulesAddScreen to resolve compilation error.
- Update: Fixed navbar inactive buttons, added MedicationOverviewScreen, and enhanced SchedulesInfoScreen with table views.
- Update: Added medicationId to DosesAddScreen for pre-selection in MedicationOverviewScreen.
- Update: Fixed amount getter error in DosesAddScreen by using _amountController.text.
- Update: Fixed syntax error in SchedulesInfoScreen and added getDoseHistory to AppDatabase.
- Update: Lightened navbar, added dose deletion, enhanced schedule alerts, fixed view statuses, and improved notification logging.
- Update: Fixed app_theme.dart constant error using Color(0xFF9E9E9E) for navbar inactive buttons.
- Update: Fixed LateInitializationError in notifications, lightened navbar, corrected Week view status, and enhanced schedule pre-selection.
- Update: Fixed initializeTimeZones error, added _weekdayToIndex, lightened navbar, and verified pre-selection.

## Project Structure
- **Flutter Code** (`lib/`):
    - `common/`:
        - `constants/`: App-wide constants (`app_colors.dart`, `app_strings.dart`).
        - `mixins/`: Reusable mixins (`controller_mixin.dart`).
        - `theme/`: Theming (`app_theme.dart`).
        - `utils/`: Utilities (`calculations.dart`, `formatters.dart`).
        - `medication_matrix.dart`: Core medication logic.
    - `data/`: Database (`database.dart`, `database.g.dart`).
    - `features/`:
        - `dose/`: Dose management (`screens/dose_screen.dart`, `screens/dose_form.dart`, `widgets/`, `constants/`).
        - `medication/`: Medication management (`screens/medication_screen.dart`, `screens/medication_info_screen.dart`, `widgets/`, `constants/`).
        - `schedule/`: Schedule management (`screens/schedule_screen.dart`, `widgets/`, `constants/`).
        - `history/`: History view (`screens/history_screen.dart`).
        - `home/`: Home screen (`screens/home_screen.dart`, `widgets/medication_card.dart`).
    - `services/`: Logic (`drift_service.dart`, `notification_service.dart`).
    - `widgets/`: App-wide widgets (`dialog_input.dart`, `form_widgets.dart`).
    - `main.dart`: Entry point.
- **Android Configuration** (`android/`):
    - `app/build.gradle.kts`: Desugaring, Java 17, v2 embedding.
    - `app/src/main/AndroidManifest.xml`: Permissions (`SCHEDULE_EXACT_ALARM`, `POST_NOTIFICATIONS`).
    - `local.properties`: Flutter SDK at `C:\Users\kook1\dev\flutter`, Android SDK at `C:\Users\kook1\AppData\Local\Android\Sdk`.
- **Dependencies**:
    - `flutter_local_notifications: ^19.2.1`
    - `flutter_riverpod: ^2.6.1`
    - `drift: ^2.22.0`
    - `get_storage: ^2.1.1`
    - `intl: ^0.20.0`
    - `logging: ^1.3.0`
    - `path_provider: ^2.1.5`
    - `sqlite3_flutter_libs: ^0.6.2`
    - `timezone: ^0.10.0`
    - See `pubspec.yaml` for full list.

## Setup Instructions
1. **Open Project**:
    - Load `C:\Users\kook1\AndroidStudioProjects\Projects\medminder2` in Android Studio.
2. **Sync Gradle**:
    - Set **Android Gradle Plugin Version** to `8.7.3` and **Gradle Version** to `8.12` in **File > Project Structure > Project**.
    - Sync via **File > Sync Project with Gradle Files**.
3. **Run Emulator**:
    - Use Pixel 6 emulator (API 34, x86_64, 2GB RAM, 512MB VM Heap, 2 CPU cores, hardware acceleration) in **Device Manager**.
    - Verify with:
      ```powershell
      adb devices
